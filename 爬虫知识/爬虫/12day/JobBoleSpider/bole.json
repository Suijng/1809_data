{"url": "http://blog.jobbole.com/114528/", "path": "bole/在 Linux 上自定义 bash 命令提示符.jpg", "title": "在 Linux 上自定义 bash 命令提示符", "desc": "尽管很多插件或工具都可以很轻易地满足这一需求，但我们也可以不使用插件和工具，自己手动自定义一些基本的显示方式，例如添加或者修改某些元素、更改前景色、更改背景色等等。 ", "content": "众所周知，（the ourne-gain ell）是目前绝大多数 Linux 发行版使用的默认 shell。本文将会介绍如何通过添加颜色和样式来自定义 bash 命令提示符的显示。尽管很多插件或工具都可以很轻易地满足这一需求，但我们也可以不使用插件和工具，自己手动自定义一些基本的显示方式，例如添加或者修改某些元素、更改前景色、更改背景色等等。在 bash 中，我们可以通过更改  环境变量的值来自定义 bash 命令提示符。一般情况下，bash 命令提示符会是以下这样的形式：在上图这种默认显示形式当中，“sk” 是我的用户名，而 “ubuntuserver” 是我的主机名。只要插入一些以反斜杠开头的特殊转义字符串，就可以按照你的喜好修改命令提示符了。下面我来举几个例子。在开始之前，我强烈建议你预先备份  文件。如上所示，bash 命令提示符一般都带有 “username@hostname” 部分，这个部分是可以修改的。只需要编辑  文件：在文件的最后添加一行：将上面的 “ostechnix” 替换为任意一个你想使用的单词，然后按  并输入  保存、退出文件。执行以下命令使刚才的修改生效：你就可以看见 bash 命令提示符中出现刚才添加的 “ostechnix” 了。再来看看另一个例子，比如将 “username@hostname” 替换为 “Hello@welcome>”。同样是像刚才那样修改  文件。然后执行  让修改结果立即生效。以下是我在 Ubuntu 18.04 LTS 上修改后的效果。如果需要仅显示用户名，只需要在  文件中加入以下这一行。这里的 \\ 就是一个转义字符串。下面提供了一些可以添加到  环境变量中的用以改变 bash 命令提示符样式的转义字符串。每次修改之后，都需要执行  命令才能立即生效。命令提示符会这样显示：如果你还需要在用户名和主机名之间显示其它字符（例如 ），可以使用以下格式：命令提示符会这样显示：命令提示符最终会这样显示：相似地，还可以添加其它特殊字符，例如冒号、分号、星号、下划线、空格等等。bash 命令提示符显示样式：如果当前目录是  ，会以一个波浪线（）显示。除了用户名和主机名，如果还想在 bash 命令提示符中显示日期，可以在  文件中添加以下内容：以上是一些常见的可以改变 bash 命令提示符的转义字符串。除此以外的其它转义字符串，可以在 bash 的 man 手册 PROMPTING 章节中查阅。你也可以随时执行以下命令查看当前的命令提示符样式。如果我不想做任何调整，直接把 username@hostname 部分整个去掉可以吗？答案是肯定的。如果你是一个技术方面的博主，你有可能会需要在网站或者博客中上传自己的 Linux 终端截图。或许你的用户名和主机名太拉风、太另类，不想让别人看到，在这种情况下，你就需要隐藏命令提示符中的 “username@hostname” 部分。如果你不想暴露自己的用户名和主机名，只需要按照以下步骤操作。编辑  文件：在文件末尾添加这一行：输入  保存并关闭文件。执行以下命令让修改立即生效。现在看一下你的终端，“username@hostname” 部分已经消失了，只保留了一个  标记。如果你想要尽可能简单的操作，又不想弄乱你的  文件，最好的办法就是在系统中创建另一个用户（例如 “user@example”、“admin@demo”）。用带有这样的命令提示符的用户去截图或者录屏，就不需要顾虑自己的用户名或主机名被别人看见了。在某些情况下，这种做法并不推荐。例如像 zsh 这种 shell 会继承当前 shell 的设置，这个时候可能会出现一些意想不到的问题。这个技巧只用于隐藏命令提示符中的 “username@hostname” 部分，仅此而已，如果把这个技巧挪作他用，也可能会出现异常。目前我们也只是变更了 bash 命令提示符中的内容，下面介绍一下如何对命令提示符进行着色。通过向  文件写入一些配置，可以修改 bash 命令提示符的前景色（也就是文本的颜色）和背景色。例如，下面这一行配置可以令某些文本的颜色变成红色：添加配置后，执行  立即生效。你的 bash 命令提示符就会变成这样：类似地，可以用这样的配置来改变背景色：大家都喜欢 emoji。还可以按照以下配置把 emoji 插入到命令提示符中。需要注意的是，emoji 的显示取决于使用的字体，因此某些终端可能会无法正常显示 emoji，取而代之的是一些乱码或者单色表情符号。如果你是一个新手，编辑  环境变量的过程可能会有些困难，因为命令提示符中的大量转义字符串可能会让你有点晕头转向。但不要担心，有一个在线的 bash  生成器可以帮助你轻松生成各种  环境变量值。就是这个：只需要直接选择你想要的 bash 命令提示符样式，添加颜色、设计排序，然后就完成了。你可以预览输出，并将配置代码复制粘贴到  文件中。就这么简单。顺便一提，本文中大部分的示例都是通过这个网站制作的。正如我在上面提到的，强烈建议在更改  文件前做好备份（在更改其它重要的配置文件之前也一定要记得备份）。这样一旦出现任何问题，你都可以很方便地恢复到更改之前的配置状态。当然，如果你忘记了备份，还可以按照下面这篇文章中介绍的方法恢复为默认配置。这篇文章是基于 ubuntu 的，但也适用于其它的 Linux 发行版。不过事先声明，这篇文章的方法会将  文件恢复到系统最初时的状态，你对这个文件做过的任何修改都将丢失。感谢阅读！ ", "img": "http://jbcdn2.b0.upaiyun.com/2018/11/c7935165018518bb315e8a1b4635c92c.jpg"}
{"url": "http://blog.jobbole.com/114570/", "path": "bole/在 Linux 命令行上拥有一头奶牛.jpg", "title": "在 Linux 命令行上拥有一头奶牛", "desc": "使用 cowsay 实用程序将牛的话语带到你的终端输出。 ", "content": "使用 cowsay 实用程序将牛的话语带到你的终端输出。欢迎来到 Linux 命令行玩具第四天。如果这是你第一次访问这个系列，你可能会问自己，什么是命令行玩具。我们也在考虑这一点，但是一般来说，这可能是一个游戏，或者任何简单的娱乐，可以帮助你在终端玩得开心。你们中的一些人会见过我们之前的选中的各种玩具，但是我们希望至少有一个对每个人来说都是新的。因为几乎所有我告诉他这个系列的人都已经问过它了，所以今天的选中的玩具是必须提及的。你也不会认为我们会在不提及  的情况下完成这个系列，对吧？ 是一个神奇的实用程序，它将文本作为 ASCII 艺术牛的讲话文本输出。你可能会发现  打包在你的默认存储库中，甚至可能已经安装了。对我来说，在 Fedora，像这样安装:然后，用  调用它，然后是你的消息。也许你想到昨天我们谈到的  连接起来。就这样！ 还有点小变体，称为 cow 文件，通常可以在  找到 ，要查看系统上可用的 cow 文件，请在  之后使用  。然后，用  试试其中之一。我对  的真正不满是，我今天没有足够的时间来为牛的挤奶 —— 一语双关。牛排价格太高了，我只是开个玩笑。更严重的是，我已经完全忘记了  直到我在学习 Ansible 的剧本时再次遇到它。如果你碰巧安装了 ，当你运行Ansible 的剧本时，你会从一队奶牛那里获得输出。例如，运行这个剧本：可能会给你以下信息： 在 GPLv3 许可证下可用，您可以在 GitHub 上找到 它的 Perl 。我也见过其他语言的版本，所以可以看看其他变体；例如，这是 。用你选择的语言实现你自己的版本可能是一项有趣的编程学习任务。既然讲完了 ，我们可以去更绿色的牧场了。你有希望我来介绍的喜欢的命令行玩具吗？这个系列的排期大部分都填好了，但我还有一些空位方。在下面的评论中让我知道，我会来看看。如果有空间，我会尝试把它包括进去。如果没有，但是我收到了一些好的意见，我在结尾提及。看看昨天的玩具，，明天再来看看另一个！ ", "img": "http://jbcdn2.b0.upaiyun.com/2018/12/8f2a2196313a36e53c18a9d2f4bbdf98.png"}
{"url": "http://blog.jobbole.com/114549/", "path": "bole/神奇的 Linux 命令行字符形状工具 boxes.jpg", "title": "神奇的 Linux 命令行字符形状工具 boxes", "desc": "本文将教你如何在 Linux 命令行终端中使用 boxes 工具绘制字符形状图形来包装你的文字让其更突出。 ", "content": "本文将教你如何在 Linux 命令行终端中使用 boxes 工具绘制字符形状图形来包装你的文字让其更突出。现在正值假期，每个 Linux 终端用户都该得到一点礼物。无论你是庆祝圣诞节还是庆祝其他节日，或者什么节日也没有，都没有关系。我将在接下来的几周内介绍 24 个 Linux 命令行小玩具，供你把玩或者与朋友分享。让我们享受乐趣，让这个月过得快乐一点，因为对于北半球来说，这个月有点冷并且沉闷。对于我要讲述的内容，可能你之前就有些了解。但是，我还是希望我们都有机会学到一些新的东西（我做了一点研究，确保可以分享 24 个小玩具）。24 个 Linux 终端小玩具中的第一个是叫做  的小程序。为何从  说起呢？因为在没有它的情况下很难将所有其他命令礼物包装起来！在我的 Fedora 机器上，默认没有安装  程序，但它在我的普通仓库中可以获取到，所以用如下命令就可安装：如果你在使用其他 Linux 发行版，一般也都可以在默认仓库中找到 。 是我真正希望在高中和大学计算机课程中就使用的实用程序，因为善意的老师要求我在每个源文件、函数、代码块等开头添加一些特定外观的备注信息。事实证明，一旦你需要在框内添加几行文字，并且格式化的将它们统一风格就会变得很乏味。而  是一个简单实用程序，它使用 ASCII 艺术风格的字符形状框来包围文本。其字符形状默认风格是源代码注释风格，但也提供了一些其他选项。它真的很容易使用。使用管道，便可以将一个简短问候语塞进字符形状盒子里。上面的命令输出结果如下：或者玩点更有趣的，比如：不要惊讶，它将会输出如下： 程序提供了 用于填充、定位甚至处理正则表达式。你可以在其  上了解更多有关  的信息，或者转到  去下载源代码或者贡献你自己的盒子形状。说到此，如果你想给你的提交找个好点子，我已经有了一个想法：为什么不能是一个节日礼物盒子？ 是基于 GPLv2 许可证的开源项目。你有特别喜欢的命令行小玩具需要我介绍的吗？这个系列要介绍的小玩具大部分已经落实，但还预留了几个空位置。如果你有特别想了解的可以评论留言，我会查看的。如果还有空位置，我会考虑介绍它的。即使要介绍的小玩具已经有 24 个了，但如果我得到了一些很好的意见，我会在最后做一些有价值的提及。你可以通过  来查看明天会介绍的命令行小玩具。 ", "img": "http://jbcdn2.b0.upaiyun.com/2018/12/93677bc0c5d849ca25cf8f39eeca8085.png"}
{"url": "http://blog.jobbole.com/114546/", "path": "bole/关于 top 工具的 6 个替代方案.jpg", "title": "关于 top 工具的 6 个替代方案", "desc": "我并不会说它们比 top 更好或者可以完全替代 top，但多了解一些类似的工具总是好的。 ", "content": "在 GitHub 和 GitLab 上，不断有来自世界各地的开源应用程序和工具涌现。其中有全新的应用程序，也有针对现有各种被广泛使用的 Linux 程序的替代方案。在本文档中，我会介绍一些针对  工具（也就是命令行任务管理器程序）的替代方案。在本文中，将会介绍以下 6 种  工具的替代方案：如果后续有更多类似的工具，原作者会在原文进行更新。如果你对此有兴趣，可以持续关注。 是一个流行的开源跨平台交互式进程管理器，也是我最喜欢的系统活动监控工具。 是对原版  工具的扩展。它最初只是用于 Linux 系统，后来开发者们不断为其添加对其它类 Unix 操作系统的支持，包括 FreeBSD 和 Mac OS。 还是一个自由开源软件，它基于 ncurses 并按照 GPLv2 发布。和原版的  工具相比， 工具有这些优势：在很多 Linux 发行版的默认软件仓库中，都带有了 。在基于 Arch 的操作系统中则可以执行以下命令来安装 ：在基于 Debian 的操作系统使用以下命令：在使用 RPM 软件管理的操作系统使用以下命令：或者在 openSUSE 系统中：不带任何参数执行  时，会显示如下画面：从图上可以看出， 会在界面顶部显示内存、交换空间、任务总数、系统平均负载、系统正常运行时间这些常用指标，在下方则和  一样显示进程列表，并且将进程的 ID、用户、进程优先级、进程 nice 值、虚拟内存使用情况、CPU 使用情况、内存使用情况等信息以多列显示出来。如果你想详细了解这些数据的含义，可以在阅读参考。和  不同的是， 支持对不同的操作使用专有的按键。以下列出一些用于与  交互的快捷键：以上这些快捷键都在  界面底部显示。需要注意的是，这其中有一些快捷键可能会与已有的快捷键发生冲突。例如按  之后可能没有进入  的设置界面，而是开始了对终端窗口的重命名。在这种情况下，你可能要更改一下快捷键的设置。除了以上列出的快捷键以外，还有一些带有其它功能的快捷键，例如： 的所有功能都可以在启动后通过快捷键来调用，而不需要在启动的时候带上某个参数。当然， 也支持带参数启动。例如按照以下方式启动  就可以只显示某个用户的进程：更改界面自动刷新的时间间隔：看， 确实比  好用多了。想了解  的更多细节，可以查阅它的手册页面：也可以查看它的 和 。 是  工具的另一个替代方案。它是一个使用 NodeJS 编写的、自由开源的命令行界面系统活动监视器，并使用 MIT 许可证发布。 通过使用 unicode 中的盲文字符来绘制 CPU 和内存使用情况的可视化图表。在安装  之前，需要先安装 NodeJS。如果还没有安装 NodeJS，可以按照进行安装。NodeJS 安装完毕之后，执行以下命令安装 ：安装好  就可以执行以下命令开始监控了。显示界面如下：如上图所示， 界面和 、 都有所不同，它将不同的内容分别以多个框的布局显示。另外在界面底部也展示了用于与  交互的所有快捷键。 有这些快捷键：想要了解更多关于  的细节，可以查阅它的或者 。 和  一样，都是一个使用 NodeJS 编写、在 MIT 许可下发布的系统活动监视器。执行以下命令安装 ：然后执行以下命令启动：显示界面如下： 有一个优点，就是它会以不同的颜色来显示不同的模块，这种表现形式非常清晰明了。主要的快捷键包括：想要了解更多关于  的细节，可以查阅它的 。 也是一个完全自由和开源的图表式系统活动监视器。顾名思义，它是在受到  和  的启发之后用 Go 语言编写的，因此也不再对其展开过多的赘述了。如果你有兴趣了解这个项目，可以阅读《》这篇文章。有些人对 NodeJS 和 Go 语言的项目可能不太感冒。如果你也是其中之一，你可以试一下使用 Python 编写的 。它同样是一个自由开源的、在 MIT 许可下发布的系统活动监视器。 同时兼容 Python2.x 和 Python3.x，因此可以使用 Python 的软件包管理器  轻松安装。如果你没有安装 ，也可以参考进行安装。安装  之后，执行以下命令就可以安装 ：又或者按照以下方式通过源代码安装：如果需要对  进行更新，可以这样操作：即使你不执行更新， 也会在第一次启动的时候提示你是否需要更新到最新的版本。现在可以看一下启动  后的界面。就像下面这样： 的快捷键包括以下这些： 还支持更改显示主题。如果你想让  更好看，可以选择你喜欢的主题。可用的主题包括以下这些：如果需要更换主题（例如更换到 colorful 主题），可以执行以下命令：使用  参数可以查看帮助页面：想要了解更多关于  的细节，可以查阅它的 。 是一个使用 Rust 编写的系统活动监视器，如果你对 Rust 感兴趣，也可以了解一下。我们最近有一篇关于  的，想要详细了解的读者不妨阅读。以上就是关于  工具的 6 个替代方案。我并不会说它们比  更好或者可以完全替代 ，但多了解一些类似的工具总是好的。你有使用过这些工具吗？哪个是你最喜欢的？欢迎在评论区留言。 ", "img": "http://jbcdn2.b0.upaiyun.com/2017/05/77d80105fd15f2465894827e23cc4842.jpeg"}
{"url": "http://blog.jobbole.com/114482/", "path": "bole/SQL优化指南.jpg", "title": "SQL优化指南", "desc": "从order by、group by、子查询和limit分页等方面介绍SQL优化方式。", "content": "开启了MySQL慢查询日志之后，MySQL会自动将执行时间超过指定秒数的SQL统统记录下来，这对于搜罗线上慢SQL有很大的帮助。以我刚安装的mysql5.7为例 查询结果是这样子的：：表示如果建立线程花费了比这个值更长的时间,slow_launch_threads 计数器将增加\n：是否开启慢查询日志 ON开启，OFF关闭 默认没有开启\n：日志保存路径：达到多少秒的sql就记录日志客户端可以用set设置变量的方式让慢查询开启，但是个人不推荐，因为真实操作起来会有一些问题，比如说，重启MySQL后就失效了，或者是开启了慢查询，我又去改变量值，它就不生效了。编辑MySQL的配置文件：加入如下三行：我这里设置的是3秒重启MySQL服务器开一个监控：客户端走一条SQL：此时发现sql已经被记录到日志里了。（有时候不一定，我看到很多博客讲的是超过指定秒数，但我实验得出的结果是达到指定秒数）explain是一个神奇的命令，可以查看sql的具体的执行计划。以一条联查sql为例：查询结果是：加上explain命令来执行：查询结果是：这就是这条SQL的执行计划，下面来说明一下这个执行计划怎么看：代表优先级  id值越大，越先执行，id值相同，从上往下执行。（比如示例的这条sql的执行计划，就是先执行第一行，再执行第二行）：表示select类型 取值如下simple 简单表 即不使用表连接或者子查询\nprimary 包含union或者子查询的主查询 即外层的查询\nunion UNION中的第二个或者后面的查询语句\nsubquery 一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询\nderived 派生表 该临时表是从子查询派生出来的\n等等：表示MySQL在表中查找数据的方式，或者叫访问类型，以下对于type取值的说明 从上往下性能由最差到最好all:全表扫描，MySQL遍历全表来找到匹配的行\nindex：索引全扫描，MySQL遍历挣个索引来查询匹配的行\nrange：索引范围扫描，常见于<、<=、>、>=、between等操作符\nref：使用非唯一索引或唯一索引的前缀扫描，返回匹配的单行数据\neq_ref：类似ref，区别就在于使用的索引是唯一索引，简单来说，就是多表连接中使用primary key或者unique index作为关联条件。\nconst/system：单表中最多有一个匹配行，查询起来非常迅速，常见于根据primary key或者唯一索引unique index进行的单表查询\nnull：mysql不用访问表或者索引，直接就能够得到查询的结果，例如select 1+2 as result。：表示查询时可能使用的索引：表示实际使用的索引：使用到索引字段的长度：扫描数量：执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息，常用取值如下：Using index：直接访问索引就取到了数据，高性能的表现。\nUsing where：直接在主键索引上过滤数据，必带where子句，而且用不上索引\nUsing index condition：先条件过滤索引，再查数据，\nUsing filesort：使用了外部文件排序 只要见到这个 就要优化掉\nUsing temporary：创建了临时表来处理查询 只要见到这个 也要尽量优化掉COUNT()是一个特殊的函数，有两种不同的作用，它可以统计某个列值的数量，也可以统计行数。在统计列值的时候要求列值是非空的，也就是不统计null。当我们统计行的时候，常见的是COUNT(*)，这种情况下，通配符*并不会像我们猜想的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数这是一个容易产生误解的事情：MyiSAM的count()函数总是非常快。不过它是有前提条件的，条件是没有任何where条件的count(*)才非常快，因为此时无须实际的去计算表的行数，mysql可以利用存储引擎的特性直接获得这个值，如果mysql知道某列不可能有null值，那么mysql内部会将count(列)表达式优化为count(*)。当统计带有where条件的查询，那么mysql的count()和其他存储引擎就没有什么不同了。（先提前申明，本人是在innodb库里做的实验。）1.count(1)和count(*)直接就是统计主键，他们两个的效率是一样的。如果删除主键，他们都走全表扫描。2.如果count(列)中的字段是索引的话，count(列)和count(*)一样快，否则count(列)走全表扫描。优化order by语句就不得不了解mysql的排序方式。1.第一种通过有序索引返回数据，这种方式的extra显示为Using Index,不需要额外的排序，操作效率较高。2.第二种是对返回的数据进行排序，也就是通常看到的Using filesort，filesort是通过相应的排序算法，将数据放在sort_buffer_size系统变量设置的内存排序区中进行排序，如果内存装载不下，它就会将磁盘上的数据进行分块，再对各个数据块进行排序，然后将各个块合并成有序的结果集。了解了MySQL排序的方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where条件和order by使用相同的索引。1.创建合适的索引减少filesort的出现。2.查询时尽量只使用必要的字段，select 具体字段的名称，而不是select * 选择所有字段，这样可以减少排序区的使用，提高SQL性能。事实上，MySQL在所有的group by 后面隐式的加了order by ，也就是说group by语句的结果会默认进行排序。如果你要在order by后面加group by ，那结果执行的SQL是不是这样：select * from tb order by … group by … order by … ？ 这不是搞笑吗？既然知道问题了，那么就容易优化了，如果查询包括group by但又不关心结果集的顺序，而这种默认排序又导致了需要文件排序，则可以指定order by null 禁止排序。例如：一个非常常见又非常头痛的场景：‘limit 1000,20’。这时MySQL需要查询1020条记录然后只返回最后20条，前面的1000条都将被抛弃，这样的代价非常高。如果所有页面的访问频率都相同，那么这样的查询平均需要访问半个表的数据。在索引上完成分页操作，最后根据主键关联回原表查询所需要的其他列的内容。例如：可以优化成这样：这种思路需要加一个参数来辅助，标记分页的开始位置：子查询，也就是查询中有查询，常见的是where后面跟一个括号里面又是一条查询sql尽可能的使用join关联查询来代替子查询。当然 这不是绝对的，比如某些非常简单的子查询就比关联查询效率高，事实效果如何还要看执行计划。只能说大部分的子查询都可以优化成Join关联查询。 可以让MySQL去参考指定的索引，但是无法强制MySQL去使用这个索引，当MySQL觉得这个索引效率太差，它宁愿去走全表扫描。。。注意：必须是索引，不能是普通字段，（亲测主键也不行）。 可以让MySQL忽略一个索引 使用了force index 之后 尽管效率非常低，MySQL也会照你的话去执行查看执行计划时建议依次观察以下几个要点：1.SQL内部的执行顺序。\n2.查看select的查询类型。\n3.实际有没有使用索引。\n4.Extra描述信息PS:一定要养成查看执行计划的习惯，这个习惯非常重要。", "img": "http://jbcdn2.b0.upaiyun.com/2018/11/b47d2553927cc1dd89135026466da892.png"}
{"url": "http://blog.jobbole.com/114573/", "path": "bole/计算机科学自学指南.jpg", "title": "计算机科学自学指南", "desc": "如果你是一名自学工程师或者是一名软件集训课程毕业的学生，有些计算机科学基础课程是你必须要补齐的，本文介绍了几个领域最佳的教材和在线视频", "content": "如果你是一名自学工程师或者是一名软件集训课程毕业的学生，有些计算机科学基础课程是你必须要补齐的。幸好，你通过互联网就能获得世界顶级的CS（计算机科学）课程。其实网上有很多学习资源但它们良莠不齐，你需要不是什么“200+免费在线课程”列表而是如下问题的答案：你应该学习哪门课程？为什么？每门课程最好的书籍或者视频，讲座是什么？我写这篇文章的目的就是尝试对于这些问题给出的明确答案：使用建议的书籍或者视频讲座来学习以下的九门科目，最好是书籍和讲座都仔细的研究一下，可以不严格按照列出的顺序来。每一门科目都需要花上100-200小时来研读，然后在你的职业生涯中对于最热爱的方向进行反复重温。有两种软件工程师：一种人对于电脑科学有很好的理解从而去从事挑战性的、富有创造力的工作。另外一种人仅仅熟悉一些高级工具，对其原理持得过且过的态度。两者都叫做软件工程师，而且两者在早期的职业生涯中可能领着同样的薪水。但是第一种工程师，不管他从事的是商业工作，还是突破性的开源工程，都会由于他的技术领导力或者杰出的个人贡献一点一点成长成一名对于编程更加痴迷而且待遇更高的工程师。第一种工程师可以通过常规手段或者在职业生涯中不断学习来加深对于计算机科学的理解深度。第二种工程师通常停留在表面，学习具体的工具或者技巧而不是其中的基础，当前流行什么技术，他们就仅仅捡起新的技能学习一下。近些年来，越来越多的人进入软件领域工作，但是本质上计算机科学的毕业生数量是没有改变的。第二种工程师的供应过量开始导致他们的就业机会变少而且导致他们离企业中令人感觉充实的工作更远。不管你是努力要成为第一种工程师或者仅仅是保险起见地想找到更多的工作，学习计算机科学是唯一一种可靠的途径。大多数大学的计算机编程课程通常以“入门类”计算机的课程开始。这些课程最好是不仅仅针对于初学者，而且对于第一次学习编程，基本概念和编程模型不是很熟悉的人也有所启发的。对于这种介绍的内容的我们给出的标准建议是经典的计算机程序的结构与解释，在网络上能找到很多这样的资料，它们可能是或者是MIT的一系列讲座。这些讲座都很不错，但是我们的视频推荐的实际上是伯克利的一门课程： 讲座 ，这个系列的课程比起MIT的讲座更精炼而且对于入门者更具有针对性。我们推荐观看完至少前三章节的SICP（《 》）并且做完相应训练。额外地，可以在  进行一些编程训练。如果你觉得SICP太难，我们推荐《 这本书。如果你觉得它太简单，我们推荐《 这本书。硬件是平台 – Mike Acton（Insomniac Games的工程总监） ()计算机结构–有的时候被称为“计算机系统”或者“计算机组织”–是了解程序外表下计算机运行的第一步。根据我们的经验，这是自学软件工程师最容易忽略的地方。，也被称为“从与非门到俄罗斯方块”。这是一本让你对于计算机中的每一个零件是怎么工作的有一个整体的理解的雄心勃勃的书。每个章节涉及到建立整体系统中一个小的部分，从写基本的逻辑门到HDL，到CPU和汇编语言，一直到完成一个俄罗斯方块应用程序。我们推荐阅读书的前六章节并且完成相关的工程。这会提高你对于计算机结构和运行的软件之间关系的理解。这本书的前半部分（和它的全部工程）在 网站上可以免费获得。在 课程网站上你也可以找到它们。为了保证课程简单并吸引人，Nand2Tetris 舍弃了深度。特别是现代计算机结构中两个很重要的概念：流水线(pipelining)和内存层级(memory hierarchy)，在书中都没有提及。当你觉得看Nand2Tetris已经很简单了，我们下一个建议是Patterson和Hennessy合著的（——一本杰出的现代经典书籍。不是书中所有的部分都很重要；我们建议跟随——（），作为特殊读物。讲座的笔记和实验环境都是在线的，而且可以在回看讲座。只有一个方法是我一直以来广泛推荐的—编码前首先要思考 — Richard Hamming我们根据几十年的通识来看，熟悉通用的算法和数据结构是计算机科学教育中最重要的方面之一。这是一个训练一个人解决问题的通用能力的方式，而且这种能力还可以迁移到其他领域的学习。这个领域有很多优秀的书籍，但是我们最喜欢的是Steven Skiena的（ 。他显然喜欢这东西而且也迫不及待地想帮助你学习数据结构和算法。这是令人耳目一新的变化，我们认为这本书相对于被更多人所推荐的Cormen, Leiserson, Rivest & Stein 或者 Sedgewick 的书来说更好。后两本书有些太过于引经据典，对于想通过阅读来解决问题的人来说并不是一个好的选择。对于那些更喜欢讲座视频的人来说，我们推荐Skiena的. 我们也喜欢Tim Roughgarden的课程，在斯坦福的MOOC平台或者上面可以获得。你喜欢 Skiena 还是 Roughgarden 的讲课风格就是你的个人喜好问题了。说到练习，我们倾向于让学生在Leetcode上面解决问题。LeetCode上面的问题都比较有趣而且有答案和讨论。这上面还可以通过解决各大软件公司广泛应用的技术问题来帮助你测试你的进步。我们建议解决你学习的时候解决大约随机100道LeetCode上面的问题。最后，我们强烈推荐《怎样解题》这本书，它针对如何解题进行了精彩绝伦和独特的讲解，既适用于数学也适用于电脑科学。如果人们不认为数学是简单的，那么他们一定没有体会过人生的艰难 — John von Neumann在某些方面，计算机科学是应用数学的一个扩展。虽然许多软件工程师忽略了这一点，我们建议你去学习它。好好学习数学会给你比那些不学习它们的人巨大的竞争优势。和CS最相关的数学领域是“离散数学”，离散是连续对立面。是微积分之外的一系列的有趣的应用数学的主题。从大体上说，尝试学会全部范围的“离散数学”是没有意义的。更现实一点的做法是对于逻辑学，组合学和概率学，集合论，图论和一些数论告知密码学有一个了解。对于计算机图像学和机器学习来说，线性代数也是一门值得学习的课程。我们建议从László Lovász的学起. 这一系列开始学习离散数学。Lovász 教授让学习的内容变得直观生动，比起拘谨的文字，这更利于你学习。接下来，我们推荐《》, 它是MIT同名课程的讲义。的视频也是免费的，而且是我们推荐的离散数学的视频课程。线性代数，我们建议从  系列开始学习，接着是Gilbert Strang的和。（）（恐龙书）和（ ）是经典的操作系统的书籍。这两本书的写作方式都饱受争议，而且为了鼓励你去购买新版，这些长达1000页的书每几年就会添加一些内容。《》这本书是一本比较好的可供选择的线上免费读物。我们特别喜欢书的结构和它经典的练习题。读完这本书，我们推荐你去探索一种特定的操作系统的设计方式，比如那些书名中有系统名字的书籍，比如 《、《》，还有 .巩固你对于操作系统的理解很好的方式是去读一个小的内核并且添加功能。xv6 是一个不错的选择，它是 Unix V6 和 ANSI C 和 X86 的接口，MIT专门有一门课程就是讲这个的。OSTEP（之前提到的）这本书有一个 XV6 的实验附录，里面都是充满潜力项目的好点子。你不能够通过凝视水晶球来预见未来。因特网未来会变成什么样，取决于如今人类如何去塑造它 — Bob Kahn考虑到很多软件项目都是基于web服务器和客户端的，计算机网络变成计算机科学中一门有实用价值的学科。系统学习过该课程的自学学生发现他们终于理解了围绕了伴随它们很多年的术语，概念，协议等等。关于这个主题我们最推荐的书是：（）。书中的小工程和实验都很好，值得一做。我们非常喜欢它们提供的 。对于那些喜欢视频课程的人，我们推荐斯坦福MOOC平台上的《》。学习网络的好处不仅仅在于做小的实验而且对于工程来说也有很大的好处。可能涉及到的有：一个HTTP的服务器，一个UDP协议的聊天软件，一个，一个代理或者负载平衡器，还有分布式的哈希表等等。对于自学者来说，学习数据库系统会比学习其他花费更多的时间。这是一个相对较新的（即1970年代后期）的研究领域。比起写书，许多潜在的杰出教科书作者更愿意去加入或者创办一家公司。在这种情况下，我们建议自学者放弃教科书而去学习伯克利的Joe Hellerstein的，看完课程再去阅读论文。对于初学者有一篇论文比较推荐的是：《，它高屋建瓴地讲解了关系数据库管理系统是如果工作的这一问题。它会为你未来的学习提供一个有用的纲要。这本书，又被称为数据库红皮书、是一本Peter Bailis、Joe Hellerstein和Michael Stonebraker编辑地论文集。对于那些理解了CS 186内容的人来说，红皮书是你的不二之选。如果你坚持要使用一本引导性的教科书，我们推荐Ramakrishnan 和Gehrke的（，对于更优秀的学生，Jim Gray的传统课程《值得一看，但是我们不建议把它当成入门书。不编大量的代码是不能很好的巩固数据库的理论的，CS 186的学生往Spark中添加功能，这是一个很有意义的工程。但是我们建议仅仅是从头写一个简单的关系数据库管理系统。功能可能不是很丰富，但是即使每一个部分都涉及到一些基本功能也很有启发性。最后，数据模型是一个数据库使用中被忽略和没有被重点学习的方面。我们对于这个课题建议的书籍是：《Don’t be a boilerplate programmer. Instead, build tools for users and other programmers. Take historical note of textile and steel industries: do you want to build machines and tools, or do you want to operate those machines? — Ras Bodik at the start of his compilers course大部分程序员学习如何使用一门编程语言，然而大部分的计算机科学家则学习这门语言本身。这给了计算机科学家比起程序员很明显的优势。他们的知识能够更好的泛化，他们能比简简单单地掌握一门语言的更加深入和快速的理解一门新语言的操作。经典的教科书（ ）通常又被称为“龙书”。不幸的是，这本书并不适合自学者，它比较适合教师从中选出1-2个章节并在课堂上讲授。这本书是有必要看的，你可以挑选里面的主题，最好再有个师傅指导你。如果你选择在自学中使用龙书，我们推荐你一系列门视频讲座，然后再沉浸在对于龙书的研究中。我们推荐的在线课程是：Alex Aiken 的，你可以在斯坦福大学的幕课平台上观看。也有可以替代龙书的教材：Terence Parr写的（，它更适合那些工作中使用类似特定领域语言的小众语言的有经验的编程者，它显得更加实用。当然，为了达到这个目的它也删去了一些有价值的理论。对于工程实践，我们推荐你写一个编译器，你可以选择像COOL这种简单的教学语言或者你感兴趣的一门语言。如果你觉得太难，你可以参考,你可以参考它作为开始。计算机的数量增长了，它们的分布也更广了。企业之前会购买越来越大型的主机，但是现在大家更倾向于在很多机器上分布式的运行多个小型的应用程序。分布式系统研究的就是这样的技术，这一技术变得越来越重要了。我们建议的自学教科书是 Maarten van Steen 和 Andrew Tanenbaum 的《 针对于之前的版本做了很大的改进，而且作者慷慨地把书放在了网上共享。由于分布式计算是一门变化很快的领域，所以没有教科书可以很好的涵盖所有的内容。但是Maarten van Steen的书是我们读过的所有书中最好的书。研究生在线课程  也是一个不错的选择，但可惜视频中的音质不太好，而且不清楚这些视频是不是都被授权过。尽管有参考书或者其它的资源，但学习分布式系统是绝对要读论文的。链接中有一个很好的，而且我们十分推荐你从 上面下载论文到本地学习。 译注：本文提到的大部分书籍，中英文版已归档至该", "img": "https://teachyourselfcs.com/sicp.jpg"}
{"url": "http://blog.jobbole.com/114493/", "path": "bole/Python 数据科学入门.jpg", "title": "Python 数据科学入门", "desc": "不需要昂贵的工具即可领略数据科学的力量，从这些开源工具起步即可。 ", "content": "不需要昂贵的工具即可领略数据科学的力量，从这些开源工具起步即可。无论你是一个具有数学或计算机科学背景的资深数据科学爱好者，还是一个其它领域的专家，数据科学提供的可能性都在你力所能及的范围内，而且你不需要昂贵的，高度专业化的企业级软件。本文中讨论的开源工具就是你入门时所需的全部内容。，其机器学习和数据科学库（、 、 、 、 、  等），以及大量可视化库（、、  等）对于初学者和专家来说都是优秀的自由及开源软件工具。它们易于学习，很受欢迎且受到社区支持，并拥有为数据科学而开发的最新技术和算法。它们是你在开始学习时可以获得的最佳工具集之一。许多 Python 库都是建立在彼此之上的（称为依赖项），其基础是  库。NumPy 专门为数据科学设计，经常被用于在其 ndarray 数据类型中存储数据集的相关部分。ndarray 是一种方便的数据类型，用于将关系表中的记录存储为  文件或其它任何格式，反之亦然。将 scikit 函数应用于多维数组时，它特别方便。SQL 非常适合查询数据库，但是对于执行复杂和资源密集型的数据科学操作，在 ndarray 中存储数据可以提高效率和速度（但请确保在处理大量数据集时有足够的 RAM）。当你使用 pandas 进行知识提取和分析时，pandas 中的 DataFrame 数据类型和 NumPy 中的 ndarray 之间的无缝转换分别为提取和计算密集型操作创建了一个强大的组合。作为快速演示，让我们启动 Python shell 并在 pandas DataFrame 变量中加载来自巴尔的摩的犯罪统计数据的开放数据集，并查看加载的一部分 DataFrame：我们现在可以在这个 pandas DataFrame 上执行大多数查询，就像我们可以在数据库中使用 SQL 一样。例如，要获取  属性的所有唯一值，SQL 查询是：利用 pandas DataFrame 编写相同的查询如下所示：它返回的是一个 NumPy 数组（ndarray 类型）：接下来让我们将这些数据输入神经网络，看看它能多准确地预测使用的武器类型，给出的数据包括犯罪事件，犯罪类型以及发生的地点：现在学习模型准备就绪，我们可以执行一些测试来确定其质量和可靠性。对于初学者，让我们输入一个训练集数据（用于训练模型的原始数据集的一部分，不包括在创建模型中）：如你所见，它返回一个列表，每个数字预测训练集中每个记录的武器。我们之所以看到的是数字而不是武器名称，是因为大多数分类算法都是用数字优化的。对于分类数据，有一些技术可以将属性转换为数字表示。在这种情况下，使用的技术是标签编码，使用 sklearn 预处理库中的  函数：。它能够对一个数据和其对应的数值表示来进行变换和逆变换。在这个例子中，我们可以使用  的  函数来查看武器 0 和 4 是什么:这很有趣，但为了了解这个模型的准确程度，我们将几个分数计算为百分比：这表明我们的神经网络模型准确度约为 82%。这个结果似乎令人印象深刻，但用于不同的犯罪数据集时，检查其有效性非常重要。还有其它测试来做这个，如相关性、混淆、矩阵等。尽管我们的模型有很高的准确率，但它对于一般犯罪数据集并不是非常有用，因为这个特定数据集具有不成比例的行数，其列出  作为使用的武器。除非重新训练，否则我们的分类器最有可能预测 ，即使输入数据集有不同的分布。在对数据进行分类之前清洗数据并删除异常值和畸形数据非常重要。预处理越好，我们的见解准确性就越高。此外，为模型或分类器提供过多数据（通常超过 90%）以获得更高的准确度是一个坏主意，因为它看起来准确但由于而无效。 相对于命令行来说是一个很好的交互式替代品。虽然 CLI 对于大多数事情都很好，但是当你想要运行代码片段以生成可视化时，Jupyter 会很出色。它比终端更好地格式化数据。 列出了一些最好的机器学习免费资源，但是还有很多其它的指导和教程。根据你的兴趣和爱好，你还会发现许多开放数据集可供使用。作为起点，由  维护的数据集，以及在州政府网站上提供的数据集是极好的资源。", "img": "http://jbcdn2.b0.upaiyun.com/2014/07/6da94dec8f6f96417f14c8291e634580.png"}
{"url": "http://blog.jobbole.com/114505/", "path": "bole/在 Linux 命令行中使用 tcpdump 抓包.jpg", "title": "在 Linux 命令行中使用 tcpdump 抓包", "desc": "tcpdump 是一款灵活、功能强大的抓包工具，能有效地帮助排查网络故障问题。 ", "content": " 是一款灵活、功能强大的抓包工具，能有效地帮助排查网络故障问题。以我作为管理员的经验，在网络连接中经常遇到十分难以排查的故障问题。对于这类情况， 便能派上用场。 是一个命令行实用工具，允许你抓取和分析经过系统的流量数据包。它通常被用作于网络故障分析工具以及安全工具。 是一款强大的工具，支持多种选项和过滤规则，适用场景十分广泛。由于它是命令行工具，因此适用于在远程服务器或者没有图形界面的设备中收集数据包以便于事后分析。它可以在后台启动，也可以用 cron 等定时工具创建定时任务启用它。本文中，我们将讨论  最常用的一些功能。 支持多种 Linux 发行版，所以你的系统中很有可能已经安装了它。用下面的命令检查一下是否已经安装了 ：如果还没有安装 ，你可以用软件包管理器安装它。 例如，在 CentOS 或者 Red Hat Enterprise 系统中，用如下命令安装 ： 依赖于 ，该库文件用于捕获网络数据包。如果该库文件也没有安装，系统会根据依赖关系自动安装它。现在你可以开始抓包了。使用  抓包，需要管理员权限，因此下面的示例中绝大多数命令都是以  开头。首先，先用  命令列出可以抓包的网络接口：如上所示，可以看到我的机器中所有可以抓包的网络接口。其中特殊接口  可用于抓取所有活动的网络接口的数据包。我们就用如下命令先对  接口进行抓包： 会持续抓包直到收到中断信号。你可以按  来停止抓包。正如上面示例所示， 抓取了超过 9000 个数据包。在这个示例中，由于我是通过  连接到服务器，所以  也捕获了所有这类数据包。 选项可以用于限制  抓包的数量：如上所示， 在抓取 5 个数据包后自动停止了抓包。这在有些场景中十分有用 —— 比如你只需要抓取少量的数据包用于分析。当我们需要使用过滤规则抓取特定的数据包（如下所示）时， 的作用就十分突出了。在上面示例中， 默认是将 IP 地址和端口号解析为对应的接口名以及服务协议名称。而通常在网络故障排查中，使用 IP 地址和端口号更便于分析问题；用  选项显示 IP 地址， 选项显示端口号：如上所示，抓取的数据包中显示 IP 地址和端口号。这样还可以阻止  发出 DNS 查找，有助于在网络故障排查中减少数据流量。现在你已经会抓包了，让我们来分析一下这些抓包输出的含义吧。 能够抓取并解码多种协议类型的数据报文，如 TCP、UDP、ICMP 等等。虽然这里我们不可能介绍所有的数据报文类型，但可以分析下 TCP 类型的数据报文，来帮助你入门。更多有关  的详细介绍可以参考其 。 抓取的 TCP 报文看起来如下：具体的字段根据不同的报文类型会有不同，但上面这个例子是一般的格式形式。第一个字段  是该数据报文被抓取的系统本地时间戳。然后， 是网络层协议类型，这里是 ，如果是  协议，该字段值是 。 是源 ip 地址和端口号，紧跟其后的是目的 ip 地址和其端口号，这里是 。在源 IP 和目的 IP 之后，可以看到是 TCP 报文标记段 。该字段通常取值如下：该字段也可以是这些值的组合，例如  代表  数据包。接下来是该数据包中数据的序列号。对于抓取的第一个数据包，该字段值是一个绝对数字，后续包使用相对数值，以便更容易查询跟踪。例如此处  代表该数据包包含该数据流的第 196 到 568 字节。接下来是 ack 值：。该数据包是数据发送方，ack 值为 1。在数据接收方，该字段代表数据流上的下一个预期字节数据，例如，该数据流中下一个数据包的 ack 值应该是 568。接下来字段是接收窗口大小 ，它表示接收缓冲区中可用的字节数，后跟 TCP 选项如 MSS（最大段大小）或者窗口比例值。更详尽的 TCP 协议内容请参考 。最后， 代表数据包有效载荷字节长度。这个长度和 seq 序列号中字节数值长度是不一样的。现在让我们学习如何过滤数据报文以便更容易的分析定位问题。正如上面所提， 可以抓取很多种类型的数据报文，其中很多可能和我们需要查找的问题并没有关系。举个例子，假设你正在定位一个与 web 服务器连接的网络问题，就不必关系 SSH 数据报文，因此在抓包结果中过滤掉 SSH 报文可能更便于你分析问题。 有很多参数选项可以设置数据包过滤规则，例如根据源 IP 以及目的 IP 地址，端口号，协议等等规则来过滤数据包。下面就介绍一些最常用的过滤方法。在命令中指定协议便可以按照协议类型来筛选数据包。比方说用如下命令只要抓取 ICMP 报文：然后再打开一个终端，去 ping 另一台机器：回到运行  命令的终端中，可以看到它筛选出了 ICMP 报文。这里  并没有显示有关  的域名解析数据包：用  参数只抓取和特定主机相关的数据包：如上所示，只抓取和显示与  有关的数据包。 可以根据服务类型或者端口号来筛选数据包。例如，抓取和 HTTP 服务相关的数据包：同样，你也可以根据源 IP 地址或者目的 IP 地址或者主机名来筛选数据包。例如抓取源 IP 地址为  的数据包：注意此处示例中抓取了来自源 IP 地址  的 53 端口以及 80 端口的数据包，它们的应答包没有显示出来因为那些包的源 IP 地址已经变了。相对的，使用  就是按目的 IP/主机名来筛选数据包。当然，可以使用多条件组合来筛选数据包，使用  以及  逻辑操作符来创建过滤规则。例如，筛选来自源 IP 地址  的 HTTP 数据包：你也可以使用括号来创建更为复杂的过滤规则，但在 shell 中请用引号包含你的过滤规则以防止被识别为 shell 表达式：该例子中我们只抓取了来自源 IP 为  或者  的 HTTP （端口号80）的数据包。使用该方法就很容易抓取到数据流中交互双方的数据包了。在以上的示例中，我们只按数据包头部的信息来建立规则筛选数据包，例如源地址、目的地址、端口号等等。有时我们需要分析网络连接问题，可能需要分析数据包中的内容来判断什么内容需要被发送、什么内容需要被接收等。 提供了两个选项可以查看数据包内容， 以十六进制打印出数据报文内容， 打印数据报文的 ASCII 值。例如，HTTP 请求报文内容如下：The document has moved .这对定位一些普通 HTTP 调用 API 接口的问题很有用。当然如果是加密报文，这个输出也就没多大用了。 提供了保存抓包数据的功能以便后续分析数据包。例如，你可以夜里让它在那里抓包，然后早上起来再去分析它。同样当有很多数据包时，显示过快也不利于分析，将数据包保存下来，更有利于分析问题。使用  选项来保存数据包而不是在屏幕上显示出抓取的数据包：该命令将抓取的数据包保存到文件 。后缀名  表示文件是抓取的数据包格式。正如示例中所示，保存数据包到文件中时屏幕上就没有任何有关数据报文的输出，其中  表示抓取到 10 个数据包后就停止抓包。如果想有一些反馈来提示确实抓取到了数据包，可以使用  选项。 将数据包保存在二进制文件中，所以不能简单的用文本编辑器去打开它。使用  选项参数来阅读该文件中的报文内容：这里不需要管理员权限  了，因为此刻并不是在网络接口处抓包。你还可以使用我们讨论过的任何过滤规则来过滤文件中的内容，就像使用实时数据一样。 例如，通过执行以下命令从源 IP 地址  检查文件中的数据包：以上的基本功能已经可以帮助你使用强大的  抓包工具了。更多的内容请参考  以及它的 。 命令行工具为分析网络流量数据包提供了强大的灵活性。如果需要使用图形工具来抓包请参考 。Wireshark 还可以用来读取  保存的 pcap 文件。你可以使用  命令行在没有 GUI 界面的远程机器上抓包然后在 Wireshark 中分析数据包。 ", "img": "http://jbcdn2.b0.upaiyun.com/2015/09/7fcd641cb5f24d14a62f52453c975c3a.jpg"}
{"url": "http://blog.jobbole.com/114490/", "path": "bole/awk 入门教程.jpg", "title": "awk 入门教程", "desc": "对于日志、CSV 那样的每行格式相同的文本文件，awk 可能是最方便的工具。", "content": "是处理文本文件的一个应用程序，几乎所有 Linux 系统都自带这个程序。它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，可能是最方便的工具。其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。的基本用法就是下面的形式。上面示例中，是所要处理的文本文件。前面单引号内部有一个大括号，里面就是每一行的处理动作。其中，是打印命令，代表当前行，因此上面命令的执行结果，就是把每一行原样打印出来。也可以处理标准输入（stdin）。上面代码中，就是把标准输入，重新打印了一遍。会根据空格和制表符，将每一行分成若干字段，依次用、、代表第一个字段、第二个字段、第三个字段等等。上面代码中，代表的第三个字段。下面，为了便于举例，我们把文件保存成。这个文件的字段分隔符是冒号（），所以要用参数指定分隔符为冒号。然后，才能提取到它的第一个字段。除了表示某个字段，还提供其他一些变量。变量表示当前行有多少个字段，因此就代表最后一个字段。代表倒数第二个字段。上面代码中，命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。变量表示当前处理的是第几行。上面代码中，命令里面，如果原样输出字符，要放在双引号里面。的其他内置变量如下。还提供了一些内置函数，方便对原始数据的处理。函数用于将字符转为大写。上面代码中，第一个字段输出时都变成了大写。其他常用函数如下。内置函数的完整列表，可以查看。允许指定输出条件，只输出符合条件的行。输出条件要写在动作的前面。请看下面的例子。上面代码中，命令前面是一个正则表达式，只输出包含的行。下面的例子只输出奇数行，以及输出第三行以后的行。下面的例子输出第一个字段等于指定值的行。提供了结构，用于编写复杂的条件。上面代码输出第一个字段的第一个字符大于的行。结构还可以指定部分。（完）", "img": "http://jbcdn2.b0.upaiyun.com/2015/02/58e81f3ff36189eef0d754b03017307d.png"}
{"url": "http://blog.jobbole.com/114479/", "path": "bole/MySQL 更改数据库数据存储目录.jpg", "title": "MySQL 更改数据库数据存储目录", "desc": "MySQL 数据库默认的数据库文件位于 /var/lib/mysql 下，有时候由于存储规划等原因，需要更改 MySQL 数据库的数据存储目录。下文总结整理了实践过程的操作步骤。", "content": "MySQL数据库默认的数据库文件位于/var/lib/mysql下，有时候由于存储规划等原因，需要更改MySQL数据库的数据存储目录。下文总结整理了实践过程的操作步骤。在更改MySQL的数据目录前，必须关闭MySQL服务。   并不是所有版本都包含有my.cnf这个配置文件，在MySQL 5.5版本，我就找不到my.cnf这个配置文件， 而有些MySQL版本该文件位于/usr/my.cnf，如果/etc/目录下没有my.cnf配置文件，请到/usr/share/mysql/下找到*.cnf文件，拷贝其中一个到/etc/并改名为my.cnf中。命令如下：编辑/etc/my.cnf文件，修改参数socket 将参数datadir修改为datadir=/u01/mysqldata/mysql/ 1： 在修改数据库的存储目录前，/var/lib/mysql/目录下根本没有mysql.sock文件，安装上面配置后，就会生成mysql.sock文件。关于mysql.sock文件，搜索了一下资料：mysql.sock是用于socket连接的文件。也就是只有你的守护进程启动起来这个文件才存在。但是你的mysql程序（这个程序是客户端，服务器端是mysqld）可以选择是否使用mysql.sock文件来连接（因为这个方法只适合在Unix主机上面连接本地的mysqld），对于非本地的任何类型的主机。那么这个文件是否一定需要的呢？ 这个需要进一步了解清楚。2：我在网上看有些网友总结的修改MySQL数据路径，有些需要给新建的目录的权限做一些处理，而有些有不用对目录权限进行授权，我没有处理，也没有什么问题。到底要不要对新的数据库目录授权呢？3：我在MySQL_5.6.20这个版本测试时，不修改my.cnf，只修改启动脚本/etc/init.d/mysql，也完全没有啥问题。也没有myssql.sock文件生成。4: 注意如果没有禁用selinux, 修改MySQL的数据路径后启动MySQL服务会遇到一些错误。关于这个的解释是后台服务都需要有对相应目录的对应权限，而 mysql 的默认路径/var/lib/mysql 已经添加了相应的策略，修改路径后由于没有相应的策略，导致后台进程读取文件被selinux阻止，从而出现权限错误。 所以要么关闭Selinux或修改文件安全上下文。", "img": "http://jbcdn2.b0.upaiyun.com/2015/11/e78e36715813f49e9e62fe0c6050075c.png"}
{"url": "http://blog.jobbole.com/114503/", "path": "bole/5 个适合系统管理员使用的告警可视化工具.jpg", "title": "5 个适合系统管理员使用的告警可视化工具", "desc": "这些开源的工具能够通过输出帮助用户了解系统的运行状况，并对可能发生的潜在问题作出告警。 ", "content": "这些开源的工具能够通过输出帮助用户了解系统的运行状况，并对可能发生的潜在问题作出告警。你大概已经知道（或猜到）告警可视化alerting and visualization工具是用来做什么的了。下面我们就要来说一下，为什么要讨论这样的工具，甚至某些系统专门将可视化作为特有的功能。可观察性Observability的概念来自控制理论control theory，这个概念描述了我们通过对系统的输入和输出来了解其的能力。本文将重点介绍具有可观察性的输出组件。告警可视化工具可以对其它系统的输出进行分析，进而对输出的信息进行结构化表示。告警实际上是对系统异常状态的描述，而可视化则是让用户能够直观理解的结构化表示。首先要明确一下告警alert的含义。在人员无法响应告警内容情况下，不应该发送告警 —— 包括那些发给多个人但只有其中少数人可以响应的告警，以及系统中的每个异常都触发的告警。因为这样会产生告警疲劳，告警接收者也往往会对这些过多的告警采取忽视的态度 —— 直到系统恶化到以少见的方式告警。例如，如果管理员每天都会收到告警系统发来的数百封告警邮件，他就很容易会忽略告警系统的所有邮件。除非他真的看到问题发生，或者受到了客户或上级的询问时，管理员才会重新重视告警信息。在这种情况下，告警已经失去了原有的意义和用途。告警不是一个持续的信息流或者状态更新。告警的目的在于暴露系统无法自动恢复的问题，而且告警应该只发送给最有可能解决问题的人员。超出这个定义的内容都不应该作为告警，否则将会对实际工作造成不良的影响。不同的告警体系都会有各自的告警类型，因此不能用优先级（P1-P5）或者诸如“信息”、“警告”、“严重”之类的字眼来一概而论，下面我会介绍一些新兴的复杂系统的事件响应中出现的通用分类方式。刚才我提到了一个“信息”这个告警类型，但实际上告警不应该是一个信息，尽管有些人可能会不这样认为。但我觉得如果一个告警没有发送给任何一个人，它就不应该是警报，而只是一些在许多系统中被视为警报的数据点，代表了一些应该知晓但不需要响应的事件。它更应该作为告警可视化工具的一部分，而不是会导致触发告警的事件。《》是这个领域的必读书籍，其作者 Mike Julian 在书中就介绍了他自己关于告警的看法。而非信息警报则代表告警需要被响应以及需要相关的操作。我将这些告警大致分为内部故障和外部故障两种类型，而对于大多数公司来说，通常会有两个以上的级别来确定响应告警的优先级。系统性能下降就是一种故障，因为其对用户的影响通常都是未知的。内部故障比外部故障的优先级低，但也需要快速响应。内部故障通常包括公司员工使用的内部系统或仅对公司员工可见的应用故障。外部故障则包括任何马上会产生业务影响的系统故障，但不包括影响系统更新的故障。外部故障一般包括客户所面临的应用故障、数据库故障和导致系统可用性或一致性失效的网络故障，这些都会影响用户的正常使用。对于不直接影响用户的依赖组件故障也属于外部故障，随着应用程序的不断运行，一旦依赖组件发生故障，系统的性能也会受到波及。这种情况对于使用某些外部服务或数据源的系统来说很常见，尽管这些外部服务或数据源对于可能不涉及到系统的主要功能，但是当系统在处理相关依赖组件的错误时可能会出现较明显的延迟。可视化的种类有很多，我就不一一赘述了。这是一个有趣的研究领域，在我这些年的数据分析经历当中，学习和应用可视化方面的知识可以说是相当有挑战性。我们需要将复杂的系统输出通过直观的方式来向他人展示，才能有效地把信息传播出去。 和  都提供了很多可视化方面的工具。下面将会介绍一些最常见的可视化创新解决方案。折线图可能是最常见的可视化方式了，它可以让用户很直观地按照时间维度了解系统的情况。系统中每个单一或聚合的指标都会以一条折线在图表中体现。但当同一个图表中同时存在多条折线时，就可能会对阅读有所影响（如下图所示），所以大多数情况下都可以选择仅查看其中的少数几条折线，而不是让所有折线同时显示。如果某个指标的数值产生了大于正常范围的波动，就会很容易发现。例如下图中异常的紫线、黄线、浅蓝线。折线图的另一个用法是可以将多条折线堆叠起来以显示它们之间的关系。例如对于通过折线图反映服务器的请求数量，可以单独看到每台服务器上的请求，也可以聚合在一起看。这就可以在同一个图表中灵活查看整个系统以及每个实例的情况了。另一种常见的可视化方式是热力图。热力图与条形图比较类似，还可以在条形图的基础上显示某部分在整体中占比的变化情况。例如在查看网络请求延时的时候，就可以使用热力图快速查看到所有网络请求的总体趋势和分布情况，另外，它可以使用不同颜色来表示不同部分的数值。在以下这个热力图中，通过竖直方向上每个时间段的色块数量分布，可以清楚地看到大部分数据集中在整个范围的中心位置。我们还可以发现，大多数时间段的色块分布都是比较宽松的，而 14:00 到 15:00 这一段则分布得很密集，这样的分布有可能意味着一种不健康的状态。还有一种常见的可视化方式是仪表图，用户可以通过仪表图快速了解单个指标。仪表一般用于单个指标的显示，例如车速表代表汽车的行驶速度、油量表代表油箱中的汽油量等等。大多数的仪表图都有一个共通点，就是会划分出所示指标的对应状态。如下图所示，绿色表示正常的状态，橙色表示不良的状态，而红色则表示极差的状态。下图中间一行模拟了真实仪表的显示情况。上面图表中，除了常规仪表样式的显示方式之外，还有较为直接的数据显示方式，配合相同的配色方案，一眼就可以看出各个指标所处的状态，这一点与和仪表的特点类似。所以，最下面一行可能是仪表图的最佳显示方式，用户不需要仔细阅读，就可以大致了解各个指标的不同状态。这种类型的可视化是我最常用的类型，在数秒钟之间，我就可以全面地总览系统各方面地运行情况。由  在 2011 年开始使用的火焰图是一种较为少见地可视化方式。它不像仪表图那样可以从图表中快速得到关键信息，通常只会在需要解决某个应用的问题的时候才会用到这种图表。火焰图主要用于 CPU、内存和相关帧方面的表示，X 轴按字母顺序将帧一一列出，而 Y 轴则表示堆栈的深度。图中每个矩形都是一个标明了调用的函数的堆栈帧。矩形越宽，就表示它在堆栈中出现越频繁。在分析系统性能问题的时候，火焰图能够起到很大的作用，大家不妨尝试一下。在告警工具方面，有几个商用的工具相当不错。但由于这是一篇介绍开源技术的文章，我只会介绍那些已经被广泛使用的免费工具。希望你也能够为这些工具贡献你自己的代码，让它们更加完善。如果你的电脑出现问题，得多亏 Stack Exchange 你才能在网上查到解决办法。Stack Exchange 以众包问答的模式运营着很多不同类型的网站。其中就有广受开发者欢迎的 ，以及运维方面有名的 。除此以外，从育儿经验到科幻小说、从哲学讨论到单车论坛，Stack Exchange 都有涉猎。Stack Exchange 开源了它的告警管理系统 ，同时也发布了 Prometheus 及其  系统。这两个系统有共通点。Bosun 和 Prometheus 一样使用 Golang 开发，但 Bosun 比 Prometheus 更为强大，因为它可以使用指标聚合metrics aggregation以外的方式与系统交互。Bosun 还可以从日志和事件收集系统中提取数据，并且支持 Graphite、InfluxDB、OpenTSDB 和 Elasticsearch。Bosun 的架构包括一个单一的服务器的二进制文件，一个诸如 OpenTSDB 的后端、Redis 以及 。 scollector 代理会自动检测主机上正在运行的服务，并反馈这些进程和其它的系统资源的情况。这些数据将发送到后端。随后 Bosun 的二进制服务文件会向后端发起查询，确定是否需要触发告警。也可以通过  这些工具通过一个通用接口查询 Bosun 的底层后端。而 Redis 则用于存储 Bosun 的状态信息和元数据。Bosun 有一个非常巧妙的功能，就是可以根据历史数据来测试告警。这是我几年前在使用 Prometheus 的时候就非常需要的功能，当时我有一个异常的数据需要产生告警，但没有一个可以用于测试的简便方法。为了确保告警能够正常触发，我不得不造出对应的数据来进行测试。而 Bosun 让这个步骤的耗时大大缩短。Bosun 更是涵盖了所有常用过的功能，包括简单的图形化表示和告警的创建。它还带有强大的用于编写告警规则的表达式语言。但 Bosun 默认只带有电子邮件通知配置和 HTTP 通知配置，因此如果需要连接到 Slack 或其它工具，就需要对配置作出更大程度的定制化（）。类似于 Prometheus，Bosun 还可以使用模板通知，你可以使用 HTML 和 CSS 来创建你所需要的电子邮件通知。 由  公司开发。你或许对 Arachnys 公司并不了解，但它很有影响力：Arachnys 公司构建了一个基于云的先进解决方案，用于防范金融犯罪。在之前的公司时，我也曾经参与过类似“（KYC）”的工作。大多数公司都认为与恐怖组织产生联系会造成相当不好的影响，因为恐怖组织可能会利用自己的系统来筹集资金。而这些解决方案将有助于防范欺诈类犯罪，尽管这类犯罪情节相对较轻，但仍然也会对机构产生风险。Arachnys 公司为什么要开发 Cabot 呢？其实只是因为 Arachnys 的开发人员对  不太熟悉。Cabot 的出现对很多人来说都是一个好消息，它基于 Django 和 Bootstrap 开发，因此如果想对这个项目做出自己的贡献，门槛并不高。（另外值得一提的是，Cabot 这个名字来源于开发者的狗。）与 Bosun 类似，Cabot 也不对数据进行收集，而是使用监控对象的 API 提供的数据。因此，Cabot 告警的模式是拉取而不是推送。它通过访问每个监控对象的 API，根据特定的指标检索所需的数据，然后将告警数据使用 Redis 缓存，进而持久化存储到 Postgres 数据库。Cabot 的一个较为少见的特点是，它原生支持 ，同时也支持 。Jenkins 在这里被视为一个集中式的定时任务，它会以对待故障的方式去对待构建失败的状况。构建失败当然没有系统故障那么紧急，但一旦出现构建失败，还是需要团队采取措施去处理，毕竟并不是每个人在收到构建失败的电子邮件时都会亲自去检查 Jenkins。Cabot 另一个有趣的功能是它可以接入 Google 日历安排值班人员，这个称为 Rota 的功能用处很大，希望其它告警系统也能加入类似的功能。Cabot 目前仅支持安排主备联系人，但还有继续改进的空间。它自己的文档也提到，如果需要全面的功能，更应该考虑付费的解决方案。 作为一家开发了  告警平台的出版公司，这是极为罕见的，当然也很值得敬佩。除此以外，Pearson 还运营着另外几个网站以及和  合资的企业。但我仍然会将它视为出版教学书籍的公司。StatsAgg 除了是一个告警平台，还是一个指标聚合平台，甚至也有点类似其它系统的代理。StatsAgg 支持通过 Graphite、StatsD、InfluxDB 和 OpenTSDB 输入数据，也支持将其转发到各种平台。但随着中心服务的负载不断增加，风险也不断增大。尽管如此，如果 StatsAgg 的基础架构足够强壮，即使后端存储平台出现故障，也不会对它产生告警的过程造成影响。StatsAgg 是用 Java 开发的，为了尽可能降低复杂性，它仅包括主服务和一个 UI。StatsAgg 支持基于正则表达式匹配来发送告警，而且它更注重于服务方面的告警，而不是服务器基础告警。我认为它填补了开源监控工具方面的空白，而这正式它自己的目标。 的知名度很高，它也被广泛采用。每当我需要用到数据面板的时候，我总是会想到它，因为它比我使用过的任何一款类似的产品都要好。Grafana 由 Torkel Ödegaard 开发的，像 Cabot 一样，也是在圣诞节期间开发的，并在 2014 年 1 月发布。在短短几年之间，它已经有了长足的发展。Grafana 基于 Kibana 开发，Torkel 开启了新的分支并将其命名为 Grafana。Grafana 着重体现了实用性以及数据呈现的美观性。它天生就可以从 Graphite、Elasticsearch、OpenTSDB、Prometheus 和 InfluxDB 收集数据。此外有一个 Grafana 商用版插件可以从更多数据源获取数据，但是其他数据源插件也并非没有开源版本，Grafana 的插件生态系统已经提供了各种数据源。Grafana 能做什么呢？Grafana 提供了一个中心化的了解系统的方式。它通过 web 来展示数据，任何人都有机会访问到相关信息，当然也可以使用身份验证来对访问进行限制。Grafana 使用各种可视化方式来提供对系统一目了然的了解。Grafana 还支持不同类型的可视化方式，包括集成告警可视化的功能。现在你可以更直观地设置告警了。通过 Grafana，可以查看图表，还可以查看由于系统性能下降而触发告警的位置，单击要触发报警的位置，并告诉 Grafana 将告警发送何处。这是一个对告警平台非常强大的补充。告警平台不一定会因此而被取代，但告警系统一定会由此得到更多启发和发展。Grafana 还引入了很多团队协作的功能。不同用户之间能够共享数据面板，你不再需要为  集群创建独立的数据面板，因为由 Kubernetes 开发者和 Grafana 开发者共同维护的一些数据面板已经可用了。团队协作过程中一个重要的功能是注释。注释功能允许用户将上下文添加到图表当中，其他用户就可以通过上下文更直观地理解图表。当团队成员在处理某个事件，并且需要沟通和理解时，这个功能就十分重要了。将所有相关信息都放在需要的位置，可以让整个团队中快速达成共识。在团队需要调查故障原因和定位事件责任时，这个功能就可以发挥作用了。 由 Netflix 开发，用于在故障发生时更有效地了解流量的情况。Grafana 是一种通用性更强的工具，而 Vizceral 则专用于某些领域。 尽管 Netflix 表示已经不再在内部使用 Vizceral，也不再主动对其展开维护，但 Vizceral 仍然会定期更新。我在这里介绍这个工具，主要是为了介绍它的的可视化机制，以及如何利用它来协助解决问题。你可以在样例环境中用它来更好地掌握这一类系统的特性。 ", "img": "http://jbcdn2.b0.upaiyun.com/2018/11/23a2beb8acbfad03600ee14aa07ce9ce.png"}
{"url": "http://blog.jobbole.com/114496/", "path": "bole/软件工程师生存指南：面试准备、工作经验和实用工具.jpg", "title": "软件工程师生存指南：面试准备、工作经验和实用工具", "desc": "软件工程师是令人羡慕的职业。但是如何才能拿到这份工作？又如何才能做好这份工作呢？拥有相关经验的Valeri Alexiev提供了相关建议和工具。其中包括了如何准备面试、如何以软件工程师的身份工作以及如何持续改进方面的经验之谈。", "content": "编者按：软件工程师是令人羡慕的职业。但是如何才能拿到这份工作？又如何才能做好这份工作呢？拥有相关经验的 Valeri Alexiev 提供了相关。其中包括了如何准备面试、如何以软件工程师的身份工作以及如何持续改进方面的经验之谈。我刚开始工作的头几年是紧张学习的时间。我得面对现实，成为软件工程师需要有很多技能，这些我之前都不知道。回顾过去，显然学会那些东西是很好的。所以我就根据自己及其他人的经验写了这篇指南来帮助入行的新人。本文将覆盖以下内容：当你开始软件工程职业生涯时，你得面对一个无可争议的事实。面试很恶心。参与其中的每个人都觉得很恶心。既被人面试过又面试过别人的我可以证明，面试是一项极其耗时、极其有压力的工作，并且面试其实并不是将来工作表现一个的好的指示器。但不管怎样，这都是一个必要之恶，你和你的简历最好还是做好准备为妥。如果你考虑做软件过程，确保了解一些最常见的编程面试问题，比如“FizzBuzz”：写一个程序打印从 1 到 100 的数字。但是如果数字是 3 的倍数的话则打印“Fizz”，如果数字是 5 的倍数则打印“Buzz”。如果同时是 3 和 5 的倍数则打印“FizzBuzz”。来自 Coding Horror听起来很简单，是吧？好吧，但其实绝大部分面试者都没能通过这一简单的测试，且不说更复杂的变种了。我个人曾经见过很多角逐资深岗位的候选人在拥有完全互联网访问的情况下没能通过这一测试。所以如果你的简历上面列有编程语言的话，确保你知道如何用它来编写实现 FizzBuzz 程序。否则的话，你只不过是在浪费所有人的时间，包括你自己的。当然，为了在面试过后生存，你需要知道的不仅仅只有 FizzBuzz。你还需要确保你知道：在职业生涯开始时，你需要就这些问题做好准备，因为你并没有经历去证明自己能做好这份工作。在准备面试的时候有两个资源我会经常推荐：为了让自己取得那点额外优势，有几件事情你可以去做。首先，学会如何沟通你的经验。你应该进行一次电梯演讲来将你的简历总结成连贯的、打动人的个人介绍。此外，要了解自己的简历！听起来很蠢是吧，但我就见过很多面试者连解释清楚自己简历上的特定事项都很困难。你应该能够回答任何有关你列上简历的经历方面的问题，并且解释清楚这一经历如何让你成为本工作更好的候选人。接着，要在 GitHub（或者其他的公共代码库）上面有一些编码的例子。眼见为实，面试官能够看到你的代码将创造奇迹。此外，这还证明了你对版本控制系统有了解。你的代码例子不需要太复杂，但是一定要整洁，能够显示出好的编码实践。这是你展示自己在没有编码面试所带来的时间压力情况下代码写得如何的机会。一旦你做完了上面的事情后，就得考虑参与一个开源项目了。参加开源项目能表明你能够在已有代码库基础上工作并且可以与其他程序员一些协作。这是你在无需实际进入一个行业环境的情况下最接近在行业环境下编程的方式了。这也是目前为止最难最耗时的一项任务，所以等到你把前面我提到的比较容易取得的果实都摘完之后再干这件事。在找工作的匆忙与压力之下，很多候选人都忘了面试是一个双向的过程。在公司努力寻找这份工作的合适人选时，你也应该设法弄清楚这家公司适不适合你。确保你也要提出以下一些问题，哪怕对方是以电子邮件的形式回复你。要意识到公司经常把不遵循最佳实践说成是一项技能，所以要体会其言外之意。知道特定岗位预期的样子很重要，因为软件工程工作差别相当大。比方说你的工作既可能是维护服务器，也可能是直接跟客户沟通。危险信号：“我不大肯定。” → 意味着面试你的那个人不在你的团队，或者他们对为什么要招你并没有明确的想法。理想情况下，验证代码质量应该是单元测试、人工测试以及自动化测试的结合。危险信号：“我们都写不出 bug，哈哈。” → 那些人正是会写出 bug 的人。版本控制系统对于协作极其有用，在职业环境下没有理由不使用。危险信号 #1：“额，版本控制系统？” → 快跑，跑得越远越好。永远记得使用版本控制。危险信号 #2：“<插入不知名的或者定制的 VCS>” → 这表明他们很有可能没有跟上时代并且很久没有升级自己的基础设施了。同行评审，或者让别人看看你的代码再把它放进代码库，这是识别愚蠢错误的极好办法，同时也是开始你的职业生涯时一个关键的培训机会。危险信号：“我们相互信任！”→很有可能那些资深开发者对自己的代码非常警惕不想给人看也不擅长接受反馈。作为一名软件工程师意味着当新技术出现、成熟并以令人眼花缭乱的速度走向过时的时候要不断学习。因此，很多公司都有培训预算用来买大学和在线课程、会议或者内部交流。危险信号：“你是说在闲暇时间读读网上的东西？” →这家公司要么资金紧张，要么把开发者视为可替代的，而不是长期投资。无论实际的细节是什么，流程对于软件工程都至关重要。至于哪些东西对于优化流程做出了贡献可能大家会有不同的看法，但仅就项目的工作方式达成一致就能将混乱最小化并且确保每个人都能达成共识。危险信号：“我们的流程受到了自由风格的爵士的影响。” → 很有可能整个部门都处在救火模式，总是不断地从紧急跳到另一个紧急状态而缺乏任何明确的目标。技术债务是过时技术以及代码库中临时应急的解决方案的累积。处理好技术债务对于代码的长期健康很重要，这件事情应该持续地做。危险信号：“我们只关注新功能。” → 他们的代码库一团糟或者很快就会一团糟。公司文化也许是个非常含糊的概念，但即便像开放办公室还是小隔间这样的小事情都会显著改变你与同事的日常互动。这方面没有普遍性的危险信号，但是要确保他们的答案是你可以按照每周 40+ 小时的节奏持续相处数年的东西。在这个阶段，如果你面试过程中表现不错并且喜欢面试官回答你问题的方式，你被录用的可能性就很高了。祝贺，你正式成为一名工程师了！那现在又该如何呢？好吧，现在是时候重新学习大量编码和工作方面的东西了。既然我们是程序员，我们就从讨论代码开始。好的行业代码有以下属性，依序是：现在你了解了如何去编写良好的行业代码了。说出来也许有点令人吃惊，但是大多数时候你都不用写新代码，而是相反，要做：因此编码以外的技能对你的职业一样关键。调试和阅读代码既然你的大量时间都是用在沟通、研究和多任务上，你需要一些工具来帮助一切井然有序。简短回答：随时都要。详细回答：99% 的时间内你都不应该重新发明轮子。在大多数的软件工程岗位，实现特定类型的东西都属于纯粹浪费时间。这并不意味着你不应该知道所使用的算法和数据结构是怎么工作的，因为这可以帮助你决定用什么以及什么时候用。为了成为一名高效的软件工程师，你需要理解自己可以任意支配使用的那些库。大多数流行语言的标准库都是极其有用的，其规模比你想象的要大。此外，代码库也许也会利用了额外的特殊库。阅读其文档，知道什么使用去使用它们。你还应该不要害怕去建议额外的库，如果它们将节省时间的话。然而，你需要确保自己选择了一个好的库供行业使用。好的库的标准是：为了替自己创建新的职业机会，除了学习会让你更擅长日常工作的技能以外，你还需要持续改进自身技能并且学习新技能。其实学习的机会有很多，而且其中很多都是你可以负担得起的：希望这篇文章能够用相关知识把你武装起来，让你了解到作为软件工程师的职业生涯伊始应该期待什么，并且提供合适的工具给你在开启这段令人兴奋的旅程中助你一臂之力！", "img": "http://jbcdn2.b0.upaiyun.com/2017/11/90129c6662feee86738bd3663ce83108.png"}
{"url": "http://blog.jobbole.com/114488/", "path": "bole/反对薪酬保密，一程序员公开了硅谷秘密.jpg", "title": "反对薪酬保密，一程序员公开了硅谷秘密", "desc": "讨论报酬水平是职场的大忌。因为这样可能会被公司炒鱿鱼。但是硅谷的软件工程师 Jackie Luo 提出，为了报酬的公平性需要提高透明度，因为只有员工才能提供公司所需的技能和经验，公司不能一手遮天。而透明性的提高需要所有员工的积极参与。她的呼吁得到了很多技术员工的响应，这篇文章就是她发现的硅谷员工的薪酬秘密。", "content": "讨论报酬水平是职场的大忌。因为这样可能会被公司炒鱿鱼。但是硅谷的软件工程师 Jackie Luo 提出，为了报酬的公平性需要提高透明度，因为只有员工才能提供公司所需的技能和经验，公司不能一手遮天。而透明性的提高需要所有员工的积极参与。她的呼吁得到了很多技术员工的响应，这篇文章就是她发现的硅谷员工的薪酬秘密。我是一名软件工程师，有 3 年的工作经验，在 Square 工作，这是一家总部位于旧金山的上市公司。我每年能赚 13 万美元，外加价值 47500 美元的股票，也就是每年 177500 美元。基本工资我没有跟他们谈。不过我的确把 4 年股票赠与从 15 万美元谈到了 19 万美元。我是在 2 月 5 号入职的。那笔赠与目前的价值是 412390.02 美元（煤炭都会波动）。如果按照这个股价行权第一年的话，我真正的报酬是 233097.51 美元。透露这一切令我感到害怕。陌生人和同行看到我挣的钱后认为我拿得太多了。（“开玩笑吧？她都干了什么能拿到这样的工资水平？”）要么他们也许会认为我拿得太少。（“如果她拿这么少的话那一定是工作不怎样。”）将来打算雇我的公司必然都会看到我之前的薪水然后将我未来的薪水锚定之前的水平，从而限制了我换工作时的涨薪水平，或者因为害怕我这个人太贵而将我排除在面试名单之外。既然这样我为什么还要分享这些数字？因为我们需要更多地讨论有关我们拿多少报酬的事情。公平报酬始于更大的透明度。在今天，性别、种族、阶层以及无数其他的身份标识在技术业的系统性偏见中都扮演着自己的角色。2018 年的一份雇佣报告发现，男性在技术业拿到的报酬要高于女性，在同一家公司担任相同角色的情况下 63% 的时候男性都要高于女性。54% 的技术女性报告说自己拿到的钱要比担任同一角色的男性要少。但我们有一个有关报酬的真诚对话可以缩小差距的乐观理由。意识到存在报酬差异的人当中有 66% 者只是在跟同事聊到报酬的情况时才知道这件事情的存在。硅谷真正的财富是通过股权产生的。通常当大家讨论报酬——该接受什么，该拒绝什么，如何协商的时候，建议总是“知道你的价值。”但怎么才能知道？对于大多数员工来说，报酬被锁在一个黑箱里面，而处在职场最上层阶梯的人掌握着所有的信息。只需要把他们支付的报酬数据给收集众多客户相关数字的机构，他们通常能获取到有关市场给特定角色开出的平均薪酬的信息，并且还能拿到聚合的分析。这种信息不对称造成了权力的失衡，只有一端，也即是更有权力的一方能够做出关于报酬支付的知情决定。典型的场景是这样的：你接受了一家公司的面试，在电话筛选上花费了几个小时，并且完成了现场面试。你表现很好。准备拿到 offer。当然了，招聘人员会打电话给你，问你想开出的报酬是多少。这个时候你就开始恐慌了。如果你报出的数字太高怎么办？你不希望公司因此不给你这个 offer 了——你需要一份工作并且已经走完了整个面试流程，所以你不希望破坏这个机会。可如果你报得太低呢？你不希望贱卖自己，而你现在协商的报酬，在你拿到那份工作之前，将决定你未来几年的报酬。拥有类似资格的其他人拿到的报酬如何？你完全就是在黑暗中乱开枪。纠正这种不平衡的努力的确有（比如 Glassdoor、Comparably 以及 Levels 这类的服务），但是聚合报酬数据的匿名平台并不能替代我们的真正需要：一种将公开讨论报酬正常化的文化。因为有感于作家 Carina Hsieh 以及#talkpay 运动，在三八国际妇女节那天我发了一条推特。它向技术界的男性发出来公开邀请，请他们与我分享自己的工资好让我可以匿名地发布出去。即便在今天，相对于自己的同行，女性以及被忽视的少数族裔还是频繁地拿到过低的报酬，而他们甚至都没有意识到这一点，因为他们没有太多的比较点。我以为会有少数人愿意直接给我发信息。迄今为止，已经有 50 万人看到了那条推特。成千上万的人已经直接私信我。大家发送了很多的工资信息给我，多到我仍然还没有把我收到的数据公布完，差得还远呢。我们保守薪水的秘密是因为我们害怕会因为分享这些数据而受到惩罚。全世界各种角色的技术员工都把自己的薪水数据发给了我，但因为我是一名湾区的软件工程师，所以我最大的数据集来自这里。那么，湾区的男性软件工程师拿到的薪水有多少呢？以下就是我对这场讨论的贡献：软件工程师开发了你每天使用的各种网站和 app。湾区的软件工程角色往往从 6 位数起步：120000 美元是 4 年大学生涯刚刚毕业的计算机科学专业拿到的典型的基本工资，这是由大型上市技术公司设定的标准。新毕业生去到小一点的初创企业能拿到的薪水可能会比这要低一点，但通常哪怕是初创企业也会支付 6 位数的工资。早期阶段初创企业给的钱最少，而真正令人安逸之心的薪酬数字只会出现在最大型的“初创企业”那里，比如 Uber、Lyft 以及 AirBnb。初创企业和上市公司的一大差异化因素是股权。初创企业的股权到头来往往一文不值，但是上市公司的股权则代表着报仇的一大部分。基本的工资很少会涨到 40 万美元以上——实际上我还没有见过——但股票则可以令工程师的整体薪酬翻番或者甚至翻 3 番。而且跟工资不一样的是，股票在价值上可以飙涨，如果你是目睹了股价坐火箭的 Google 员工或者你是一家初创企业的第一名工程师而那家公司后来被高价收购的话这一点是真的。硅谷的真正财富是通过股权产生的。尤其是 Facebook 和 Google 对于迫切需要的人才开出的薪酬是最丰厚的。尽管市场竞争激烈，但如果你听说一位工程师的总报酬达到 75 万美元的话，那一定是非常不典型的。很有可能他们是在 Facebook 或者 Google 工作，而且是全世界稍有的几个具备行业经验与专业知识能从事相关工作的人。他们就是戴着“金手套”的人：理论上他们可以在任何地方找到一份工作，但是他们无法离开（或者至少他们认为自己不能离开），因为没有一个竞争对手能配得上他们的报酬。大家通常会担心自己会因为分享自己的收入而被炒鱿鱼。如果让我来猜测湾区软件工程师的平均总薪酬（基本工资、股权加奖金）的话，我想大概在 150000 美元到 200000 美元之间。这个估计得到了我从 Twitter 收到的数据的支持，其中位数是 183750 美元。根据 Glassdoor，工程师的平均基本工资是 137000 美元，奖金为 11000 美元，这还没有包括股票奖励。这个数字已经不少了，所以这个话题的敏感性也不足为奇。尽管如此，我对披露报酬数字给我的人的害怕程度仍然准备不足，很多人一而再再而三地向我强调这一信息只能匿名发出。好几位甚至还要求自己的工作城市和职位细节信息要尽可能写得含糊，以防自己正好被对上号。大家往往会担心自己因为分享收入信息而被炒鱿鱼。对待透明性的态度是文化已经受到严重破坏的迹象。我们如何得到报酬塑造了我们得日常生活的一切：我们可以在哪里生活，可以做什么，可以有多大的自由。在收入方面更清楚了解到我们所处的位置完全是我们的利益所在，但是我们还是要保守这一信息秘密，因为我们害怕会由于分享而受到惩罚。在一个本该极其重视透明性的行业里，我们在最需要透明性的地方却恰恰存在不足。让我们改变这一权力格局吧。跟你的同事讨论，跟你的业界同行讨论，跟你的朋友讨论自己拿到了多少报酬。跟你团队里面的女性和少数族裔讨论。不要仅仅讨论工资，要讨论整体报酬包括股权和奖金在内。讨论相关过程，比如你的报酬如何改变了自己的职业生涯路径以及协商报酬最后对拿到 offer 的影响会怎样。邀请他们也做同样的事情。大家的共同看法是公司在就业市场拥有一切权力因为就业机会是它们赋予的。但员工才是提供公司所需技能和经验的人。知道自己应该拿多少让你在一个通常不钟爱于你的体系里面多少有一点权力——而你应该运用这种权力。", "img": "http://jbcdn2.b0.upaiyun.com/2018/11/89f21f4108d88a3eabb105a24c0f4fad.jpeg"}
{"url": "http://blog.jobbole.com/114523/", "path": "bole/网络应用优化——时延与带宽.jpg", "title": "网络应用优化——时延与带宽", "desc": "本文网络应用优化中最重要的两个目标：时延与带宽。通过定义并区分两者的关系，并引申出网络服务优化的几种基本方法。", "content": "", "img": "http://jbcdn2.b0.upaiyun.com/2016/04/149000d5c8b1bb08b8de6914ed749f28.gif"}
{"url": "http://blog.jobbole.com/114589/", "path": "bole/救命！我的电子邮件发不到 500 英里以外！.jpg", "title": "救命！我的电子邮件发不到 500 英里以外！", "desc": "这是一个听起来几乎不可能的事情……我甚至有点后悔将它发到网上，因为它在一个会议上成了一则著名的酒后故事。 ", "content": "这是一个听起来几乎不可能的事情……我甚至有点后悔将它发到网上，因为它在一个会议上成了一则著名的酒后故事。这个故事略有改动，以保护故事中的人物，以及忽略了一些无关的细节使之更有趣一些。几年前，当我接到统计系主任的电话时，我正在从事维护校园电子邮件系统的工作。“我们从部门发送电子邮件时遇到了问题。”“有什么问题？” 我问。“我们不能发送超过 500 英里的邮件，”主任解释说。“咳咳”，我被我喝的拿铁呛了一口，“您再说一遍？”“我们不能发送距这里超过 500 英里的邮件，”他重复道。 “实际上，更远一点，是 520 英里，但不能更远了。”“嗯……电子邮件真的不会这样，通常，”我说，试着让我的声音听起来不那么慌乱。我不能和一个系主任说话时显得慌乱，即使是一个像统计系这样的相对没钱的院系。 “是什么让你觉得你不能发送邮件超过 500 英里？”“这不是我，”主任有点急躁地回答道。 “我们首先注意到了这种情况是几天前。”“你等了？” 我打断他，带点颤音说道。 “这段时间你一直你不能发送电子邮件？”“我们可以发送电子邮件。只是不超过 ——”“—— 500 英里，我知道，”我接过他的话，“我知道了。但为什么没有你早点打电话呢？”“好吧，我们没有收集到足够的数据来确定发生了什么，直到现在。”没错，这是系的主任。“不管怎么说，我请了一位地理统计学家研究它 ——”“地理统计学家……”“—— 是的，她制作了一张地图，显示了我们发送电子邮件能够达到的半径略超过 500 英里。在那个半径范围内有零星的几个无法到达的目的地，但我们永远不能发送比这半径更远的电子邮件。”“我明白了，”我说，把头埋在我的手中。 “这是什么时候开始的？几天前，你说过，但是那时你的系统做了什么改变？”“嗯，服务顾问来给我们的服务器打了补丁，并重新启动了它。但我打电话给他，他说他没有碰过邮件系统。”“好的，让我来看看，我稍后会给你回电话，”我说。我简直觉得我在做梦，这不是愚人节。我试着回想是不是有人恶作剧报复我。我登录了他们系的服务器，并发送了一些测试邮件。在北卡罗来纳州的三角研究园（ Research Triangle Park），我自己的帐户的测试邮件顺利投递。发往里士满、亚特兰大和华盛顿的也是如此。发往普林斯顿（400 英里）的另一个邮件也正常。但后来我尝试向孟菲斯（600 英里）发送电子邮件，失败了。波士顿，失败了。底特律，也失败了。我拿出了我的地址簿，开始试图缩小它的范围。纽约（420 英里）工作，但普罗维登斯（580 英里）失败了。我开始怀疑自己是不是疯了。我试过给住在北卡罗来纳州的朋友发电子邮件，但他的 ISP 在西雅图。谢天谢地，它失败了。如果问题与收件人的地理位置有关，而不是他的邮件服务器，我想我要哭了。已经确定！虽然令人难以置信，但所报告的问题是真实的、可重复的，我看了一下  文件。它看起来很正常。事实上，它看起来很熟悉。我把它与我主目录中的  做了个对比。它没有被改过 —— 这是我写的 。 而且我相当确定我没有启用某种 “” 选项。我不知所措，我 telnet 到 SMTP 端口。 服务器愉快地回复了 SunOS sendmail 的横幅消息。等一下……一个 SunOS sendmail 的横幅消息？当时，即使 Sendmail 8 已经相当成熟，Sun 公司在其操作系统中装的仍然是 Sendmail 5。作为一名优秀的系统管理员，我已经对 Sendmail 8 进行了标准化。并且作为一名优秀的系统管理员，我编写了一个 ，它使用了 Sendmail 8 中提供的很长的、具有自我描述意义的选项和变量，而不是 Sendmail 5 中使用的那种神秘的标点符号式配置选项。这个细节一下子又回到了起点，我再次被我现在已经冷掉了的拿铁咖啡渣呛了。 当服务顾问“对服务器打补丁”时，他显然升级了 SunOS 的版本，并且这样做 Sendmail。这次升级会将 sendmail.cf 单独留下，即使它现在是错误的版本。事实上，Sendmail 5 —— 至少是 Sun 所带的版本，是有一些调整的 —— 它可以处理 Sendmail 8 的 ，因为大多数规则在那时保持不变。但新的长配置选项 —— 它被视为垃圾，并跳过。 并且  二进制文件编译时没有针对其中大多数设置默认值，因此，在  文件中找不到合适的配置，它们被设置为 0。被设置为  的配置之一是连接到远程 SMTP 服务器的超时选项。 一些实验证明，在具有典型负载的特定机器上， 超时将在稍微超过 的时间内中止连接调用。当时我们校园网络的一个奇怪的特点是它是 100％ 交换的。传出的数据包不会出现路由器延迟，直到命中 POP 服务器并到达远端的路由器。因此，连接到附近网络上的轻负载的远程主机的时间实际上主要取决于到目的地的光速的速度，而不是偶然的路由器延迟。这让我有点晕，我在我的 shell 中输入：“500 英里，或者稍微多一点点。”", "img": "http://jbcdn2.b0.upaiyun.com/2018/12/36e31dd89e6544ad8e05bb49bb1da4c7.jpg"}
{"url": "http://blog.jobbole.com/114499/", "path": "bole/程序员神器 StackOverflow 10 岁了，它长大后想成为什么？.jpg", "title": "程序员神器 StackOverflow 10 岁了，它长大后想成为什么？", "desc": "今年 9 月，程序员必备神器之一的 Stack Overflow 正式成立 10 周年了。截至目前为止，SO 用户量高达 930 万，也许你经常在 SO 上找解决方案。但你可能还不真正了解 SO。来看看 SO 创始人 Jeff Atwood 是怎么说的。", "content": "【伯乐在线导读】：今年 9 月，程序员必备神器之一的 Stack Overflow 正式成立 10 周年了。截至目前为止，SO 用户量高达 930 万，也许你经常在 SO 上找解决方案。但你可能还不真正了解 SO。来看看 SO 创始人 Jeff Atwood 是怎么说的。 现实生活中常常有人问我，我的工作是什么，对此我有一个 15 秒的回答：我们创建了一个类似维基百科的网站，程序员们可以在上面发表或者解答问题。网站的名字叫 。截至 2018 年 9 月，Joel Spolsky 与我共同创建的 Stack Overflow 已经走过了 10 个年头。从 2012 年开始我就在做其他的工作了，但是能让人们在我过世之后还能想起我的东西，那肯定还是我的老伙伴 Stack Overflow。这里我好像应该滔滔不绝地说 Stack Overflow 有多么优秀，而我作为创始人是有多么伟大。但I这些我都不在乎。我真正在乎的是，Stack Overflow 对程序员们是不是有帮助。对此，让我们看看如今最牛叉的开发者之一，我的偶像 John Carmack 是怎么评价的。 在为提升开发者的效率方面，Stack Overflow 可能贡献了好几十亿美元说实话，2013 年 9 月 17 日是很美好的一天。我读到这条推的时候吓了一跳，不光是因为我经常用 Carl Sagan 的方式读 Billions 这个词。我在 Twitter 每隔几天就会读到一些残酷无尽的人间疾苦，以及人们在网络上的互相叫骂。与此相反，那一天是我感觉到的只有喜悦。这也提醒了我，我该查查 Twitter，看看如今谁还对网络抱有不同的理解。Stack Overflow 有着如此多用户，也帮助了一个时代的开发者，对此我感到既荣幸又谦卑。但是，实现这一成就的并不是我。世界各地开发者们所贡献的那些大大小小的提问与回答，把 Stack Overflow 变成了一个在开发领域能与维基百科抗衡的创意共享知识库。这实在是…非常的不可思议。不过成功的故事都很无聊。这个世界上有很多人，本身运气好，但还时不时的告诉别人是自己的努力以及喝活力汽水换来了成功。我觉得失败的故事更有教育意义，在建立业务与规划未来时，我把自己想象成深渊专家，并开始一场比赛。这是我自己做事的习惯。由此，我现在要与耀眼的深渊对视，预测一下Stack Overflow未来十年会遇到的挑战。这之前，我要先澄清以下事实。你问我对如何运作Stack Overflow 竟然能没有建议？额，那你可能不认识我。你问我难道我不会时不时给员工发邮件告诉他们我的想法？我也许会吧，但是我为数不多的归档邮件可以证明，这个事情很少发生。，他们中的大多数（包括我离开之前的 Stack Overflow 社区成员）都能对我们的使命给出更好的，不像我那样胡思乱想的阐述。我会用生命信任他们吗？不会。但是我会用 Joel 的生命信任他们！Stack Overflow 的运作靠的是世界各地日复一日做开发的人们，就像你或我一样。我觉得 Stack Overflow 就像个家长，它的目标是让孩子们最终能离开家长身边，成为可以独当一面的大人。4、作为 Stack Overflow 的创始人，我在社区成立的最初四年里，花了非常多的时间参与制定规则与规范。你现在阅读的是我所。这只是我的一些想法，我也希望自己的预测是准确的，但是这并不意味着我可以预测未来，或者我有资格去预测未来。不过我并不会以自己是否具有资格而不去做一些事情。Stack Overflow不仅是个论坛，它跟维基百科有很多相似之处。我们衡量问题和答案是否有意义的方式，不是看那些问题和答案对特定几个人的帮助，而是看随着时间的推移，这些问题和答案能不能帮助到越来越多的人。我从 后就在强调这个关系。来看看下面谁的地位最高。为了强调这一核心价值，Stack Overflow添加了一个简洁的功能。那就是在用户资料里会显示，你所贡献的问题与回答帮助到了多少人。这些问答内容到底服务于谁？回答问题为何有如此严格的审核过程？对于 Stack Overflow 最常见的抱怨通常来自于对前面这两个问题的误解。 我希望更多的人能明白，Stack Overflow并不是一个“回答我的问题”的地方，它是“让我们合作建立一个对未来的开发者们有益的地方”。也许 Stack Overflow 应该更加努力去帮助用户理解这件事。如今很多用户，甚至泡在 Hacker News 上的技术圈网友，都不知道 Stack Overflow 上有个功能，那就是每一个问题都是可以修改的，即使是没有登录的匿名用户也可以修改。对此我深表惊讶。这个功能不奇怪，对吧，因为 Stack Overflow 就是一种维基百科，这也是维基百科的运行模式，任何人都可以修改任何内容。不信的话，现在就去试试吧，找一个你认为可以提高的问题或者回答，点击“改善这个回答（improve this answer）”或者“改善这个问题（improve this question）”，然后写下你的改良版。Stack Overflow 有很多功能（甚至也包括我自己在 2012 年之前的一些所作所为）都容易导致用户误解其核心价值。理论上，“如今每一个开发者都听过，用过以及了解 Stack Overflow”，但我觉得这个假设不准确。毕竟每时每刻都有新的开发者诞生。说得更复杂一点，Stack Overflow 的使用模式有三种，从大到小，以倒金字塔的形式排列如下：用户直接上网搜索，搜索引擎会直接显示出 Stack Overflow 中的高票答案。出现在搜索引擎第一页，这也是Stack Overflow的主要目标。如Stack Overflow正常运行，98%的开发者在他们的整个职业生涯中，不需要主动提出或者回答问题。只要通过网络搜索就可以找Stack Overflow上到他们需要的结果。这是个好事，非常好的事。只在遇到难以解决的困难时，参与Stack Overflow的讨论，这很合理。然而，我觉得这个阶层的用户最容易感觉到Stack Overflow不是那么容易使用，因为这类用户可能对Stack Overflow很熟悉，但是并不清楚发布问题的流程。并且在他们急切想寻找答案的时候，他们没有时间或心思去应对Stack Overflow对于问题背景、格式、描述以及引用要求。这个阶层的用户很有经验，他们贡献了很多答案，也了解什么样的问题是好问题，是他们感兴趣、愿意回答的问题。他们不经常提问，因为他们知道如何去全面搜索他们想要的答案。但是他们一旦提问，那一定是个示范性的好问题。（理论上这里还有个第四阶层用户，他们无私的贡献了很多提问与回答，目的只是为了推动软件开发行业的发展，造福于新一代的开发者们。但是我们没空提这些大神，你们只会让我们显得更加平凡，所以我们就此打住吧）第一阶层的用户在社区里开心地逛了好几年，却在变为第二阶层用户时，一下子有了不开心的用户体验。对此我一点儿也不惊讶。我认为解决这个问题最主要的方式，就是改变并提高提问页面的用户体验。另外值得注意的一点是，用户在提出了某个问题后，可能收到关于问题信息不足的负面反馈，但是他们也许并不知道，你的问题应该是“有益于其他用户而并不只是你自己”。Stack Overflow采用了维基百科的模式，也使其自身受到了很多限制。即使用户在提问前就知道这些，很多时候到底什么是“有用的信息”也很难判断。同理，很多时候我们也不确定到底什么样的话题，人群或者地点需要一份维基百科。 有自己的维基百科页面，这毫无争议，但是他住在奥哈马市的表兄 Dave，那个提出了一个关于 PHP 5.6 的奇怪问题的人，是不是该被写入维基百科呢？这事我很早就预料到了。老实说，我有点庆幸自己在 2012 年离开了 Stack Overflow，这样我就不用去处理这个难以置信的技术性难题：重复性内容。在我听到的关于 Stack Overflow 的所有抱怨里，重复内容是我觉得最有共鸣的。如果你接受Stack Overflow是个类似于维基百科系统这一前提，那同理你显然不能接受，在维基百科中，对于意大利有五个不同的词条。Stack Overflow不允许对于同一个技术问题有重复的提问。我们确实有很多避免重复问题的功能，比如输入问题时的同步搜索，以及提交问题前，你会看到一个很明显的，鼓励用户先去搜索相关问题的搜索框。… 如何查找并判断重复内容是个非常有难度的问题，即使是Google这样的公司，有着名副其实世界最聪明的工程师团队，专攻了20年也没有解决这个问题。当你在一个不允许重复问题的网站中提问时，系统去重的难度取决于总问题数量，处理一百万的问题总量的去重与一千万甚至一亿相比，是非常不同的。系统处理问题去重的难度，会从不太难处理变为最终的完全无法处理。比如你提出了一个与艺术类相关的问题，那么系统需要根据你的提问内容，在不胜枚举的已有问题中进行筛选，以确保没有看起来相似的提问。等会儿，还有个更难的问题！我对于越来越严重的重复问题并没有一个好的解决方案。但是我想指出，早期在  有很多先例，它们把网站分为“初级”和“高级”区域，不同区域的规则不同。我们在别的地方也能找到类似的例子，比如 Math 和 MathOverflow，English 和 English Learners， Unix 和 Ubuntu，也许是时候搞一个以初级用户为主的 Stack Overflow了，在那里我们可以允许多一些重复，少一些规则。Stack Overflow确实是个相当明确的竞争性系统，它的一大标志就是。根据我的多年观察，激励开发者最有效的方式就是…巧妙地暗示出别人的解决方案也许比你的更好。 – 你好Randall。医生说你能听到我说话，虽然你看起来像植物人。我是来告诉你，别着急慢慢康复。因为Ross接替了你的工作，并且做的非常好。他甚至找到了你代码里的瓶颈，还说他改过的代码变快了两倍。– 这不可能！！！！！我现在就回办公室！Stack Overflow的竞争性质体现在了它的公开声望系统上，就是。所有的声望值都来源于其他用户，而不是所谓的系统。每当你提出问题或者提交回答时，你的问题或回答都可以被其他用户指指点点，他们可以编辑、标记、关闭、打开、顶、踩或者收起。这样做的目的是让 Stack Overflow 成为一个同行评审和友好竞争的系统，就像在公司里，你的代码被你从没见过的另一个部门的人来评审。有人以友好的方式去质疑你所提问题的提论，也是完全合理的，比如，？我完全清楚这种竞争性质的同行评审系统，并不适合每一个人。Stack Overflow 采用维基百科的模式，导致它存在不能接受重复内容这样的限制。那么根据你的情况与背景，同行评审时，你收到的评价可能会让你觉得不舒服。我听部分用户反应，在 Stack Overflow 提问的过程中会感觉到焦虑。对我来说，在 Stack Overflow上提问，应该感受到一种 ”我要展示出我最好的一面“ 的正常焦虑：至于那种完全不会感到焦虑的地方，我唯一能想到的就是，从事了很久的工作，已经不再关注与工作本身，因此也没有那种担心有一天就会丢了工作的焦虑。这样怎么会好呢？所以说我不喜欢零焦虑的系统。也许你不喜欢竞争。那么能不能有个少量竞争模式的问答系统呢？一个没有投支持或者反对票功能的系统，这样无论发表什么内容都不会感觉焦虑。这就像是一个全是你的支持者的网络，大家都相信你，希望你成功。这当然也是可以的。我认为应该有类似这样的网站，用户可以根据自己的需求与目标来选择适合自己的体验。那么 Stack 应该建立一个这样模式的社区吗？这样的社区已经有了吗？这是个开放题。也请随意在留言区发表你的看法。Stack Overflow的目标用户到底是谁，这也是经常容易被混淆的一点。这个回答很直观，而且从从未改变过：一个为专业和热情的程序员而存在的问答平台。这是指：当前正在从事程序开发职业的人，或者如果愿意就能立即胜任程序开发工作的人。如果你觉得好奇，这个定义的一部分是公开的商业决策。为了盈利，你的用户群体必须要有一部分拿着开发者薪水的人，或者在找开发者的工作的人。整个 Stack Overflow 社区也许有着知识共享的标签，但是它并不是个非营利组织。我们的出发点是可持续经营，这也是为什么我们在 Stack Overflow 上线一年之后，就成立 的原因，回顾一下，成立的确实有点过早了。为了实现比 2009 好很多的集成化用户体验，招聘平台被归入了 Stack Overflow，放在了 下面。用户的选择定位并不是说要排斥非开发者，但是 Stack Overflow 确实是一个有着严格同行评审，对已经在从事相关行业的人来说非常优秀的功能，但同时也是对于学生或者初学者来说很不友好的功能。这也是为什么，我每次在推特上，看到有人推荐学生去 Stack Overflow 找答案时，我会小心翼翼的建议不要这样。对于开发领域的新手或者学生来说，他们需要的，与 Stack Overflow 所提供的是完全相反的。他们需要的是：这些都是对初学者来说，很好很合理的事情，但是 Stack Overflow 一个也不做。你可以通过 Stack Overflow 来从头学习如何编程吗？理论上你可以通过任何软件做任何事情，你甚至可以通过 Reddit 与人进行日常交流，如果你是受虐狂的话。但是答案还是肯定的，理论上你可以通过 Stack Overflow 学习如何编程，如果你是喜欢竞争模式（声望、被关闭、被踩）的神童，也完全能接受要去帮助别人而不只是自己学习知识这一观点。但是我强烈不推荐这样做。对初学者来说，除了 Stack Overflow 外还有。那么 Stack Overflow 能不能成为一个适合新手和学生的平台呢？我不清楚，我也不能决定。这些就是我要说的。我们可以不再与深渊对视。我希望我的观点对 Stack Overflow 不会有什么负面影响。总的来说，我认为目前的 Stack Overflow 很强大。但是，无论是 还是2018 年，我怎么想有关系吗？Stack Overflow 是你们的。 Stack Overflow 将信念赌在了这一点：信任你的同行。Stack Overflow 的成长离不开那些积极参与社区讨论的开发者们。是你们让我相信开发者社区是最好的学习与成长的地方。是你们让我收获了如此多的对于 Stack Overflow 的赞誉。这不是我的功劳，而是你们的。 很久之前我在 Code Horror 上就知道了合作的力量是多么强大。目前我们的社区已经达到我今生难以企及的高度。我唯一能要求的，或者是我们能要求的，就是大家互相帮助互相成长。 如果有人认可了你的付出，那么你值得为此感到骄傲。开发者社区的力量能够创造以及终结 Stack Overflow。Stack Overflow 长大了会成为什么？它的未来将由我们共同创造。PS：Stack Overflow 十周年快乐！", "img": "http://jbcdn2.b0.upaiyun.com/2016/03/6dd085bf97f82f786b71b4fbcdb37e88.jpg"}
{"url": "http://blog.jobbole.com/114561/", "path": "bole/Linux 搜索文件和文件夹的 4 种简单方法.jpg", "title": "Linux 搜索文件和文件夹的 4 种简单方法", "desc": "Linux 管理员一天都不能离开搜索文件，因为这是他们的日常活动。 ", "content": "Linux 管理员一天都不能离开搜索文件，因为这是他们的日常活动。了解一些搜索的东西是不错的，因为这能帮助你在命令行服务器中工作。这些命令记忆起来不复杂，因为它们使用的是标准语法。可以通过四个 Linux 命令啦执行此操作，每个命令都有自己独特的功能。 命令被广泛使用，并且是在 Linux 中搜索文件和文件夹的著名命令。它搜索当前目录中的给定文件，并根据搜索条件递归遍历其子目录。它允许用户根据大小、名称、所有者、组、类型、权限、日期和其他条件执行所有类型的文件搜索。运行以下命令以在系统中查找给定文件。运行以下命令以查找系统中的给定文件夹。要在 Linux 中搜索文件夹，我们需要使用  参数。使用通配符搜索系统上的所有文件。我们将搜索系统中所有以  为扩展名的文件。使用以下命令格式在系统中查找空文件和文件夹。使用以下命令组合查找 Linux 上包含特定文本的所有文件。 命令比  命令运行得更快，因为它使用  数据库，而  命令在真实系统中搜索。它使用数据库而不是搜索单个目录路径来获取给定文件。 命令未在大多数发行版中预安装，因此，请使用你的包管理器进行安装。数据库通过 cron 任务定期更新，但我们可以通过运行以下命令手动更新它。只需运行以下命令即可列出给定的文件或文件夹。在  命令中不需要指定特定选项来打印文件或文件夹。在系统中搜索  文件夹。在系统中搜索  文件。 返回在终端输入命令时执行的可执行文件的完整路径。当你想要为可执行文件创建桌面快捷方式或符号链接时，它非常有用。 命令搜索当前用户而不是所有用户的  环境变量中列出的目录。我的意思是，当你登录自己的帐户时，你无法搜索 root 用户文件或目录。运行以下命令以打印  可执行文件的完整路径。或者，它允许用户一次执行多个文件搜索。 命令用于搜索给定命令的二进制、源码和手册页文件。 ", "img": "http://jbcdn2.b0.upaiyun.com/2018/12/6d2225e2460121a0b2f5343e5b212231.jpg"}
{"url": "http://blog.jobbole.com/114536/", "path": "bole/正则表达式的隐藏陷阱，你都了解么？.jpg", "title": "正则表达式的隐藏陷阱，你都了解么？", "desc": "想不到，一行不起眼的正则表达式，竟然会让你的CPU挂死，这个正则表达式的陷阱你遇到过吗？", "content": "几天前，一个在线项目的监控系统突然报告了一个异常。在检查了相关资源的使用率后，我们发现 CPU 利用率接近 100%。然后，我们用 Java 附带的线程转储工具导出了这个异常相关的堆栈信息。我们发现，所有堆栈信息都指向一个名为 “validateUrl” 的方法，它在堆栈上有超过 100 个错误消息。通过检查代码，我们发现该方法的主要功能是验证 URL 的合法性。一个正则表达式是如何导致如此高的 CPU 利用率的呢？为了重现这个错误，我们提取了关键代码，并进行了简单的单元测试。当我们运行上面的示例时，资源监视器显示，一个名为  的进程 CPU 利用率已经飙升到 91.4%。现在我们几乎可以判断，正则表达式是导致 CPU 利用率飙升的原因。所以，让我们聚焦于正则表达式：这个正则表达式看起来并没有什么异常。它可以分为三部分：第一部分用于匹配  和  协议。 第二部分用于匹配  字符。第三部分用于匹配剩余字符。我盯着这个正则表达式看了很久，也没发现什么大问题。事实上，Java 用来处理正则表达式所用的  引擎是引起高 CPU 利用率的关键。当进行字符匹配时， NFA 会使用一种称为“回朔法”（backtracking）的方法。一旦发生回溯，所花费的时间将变得非常长。可能是几分钟，也可能长达数小时。所需时间的长短取决于发生回溯的次数和回溯的复杂度。也许有些人还不太清楚回溯是什么。没关系，让我们从正则表达式的原理开始。正则表达式是一组便于匹配的符号。为了实现如此复杂且强大的匹配语法，我们必须有一组算法，算法的实现称为正则表达式引擎。简而言之，正则表达式的实现引擎有两种：一种是  (有穷确定自动机 Deterministic Final Automata)，另一种是  (有穷非确定自动机 Non deterministic Finite Automaton).这是两种不同的自动机。在这里，我们不会深入讨论它们的原理。简单地说， 的时间复杂度是线性的。它更稳定，但功能有限。 的时间复杂度相对不稳定。 根据正则表达式的不同，时间有时长，有时短。 的优点是它的功能更强大，所以被 Java、.NET、Perl、Python、Ruby 和 PHP 用来处理正则表达式。 是怎样进行匹配的呢？我们用下面的字符串和表达式作为例子。记住， 匹配是基于正则表达式的。也就是说， 将依次读取正则表达式的匹配符，并将其与目标字符串进行匹配。如果匹配成功，它将转到正则表达式的下一个匹配符。否则，它将继续与目标字符串的下一个字符进行比较。让我们一步一步地来看一下上面的例子。以上是  的匹配过程。实际的匹配过程要复杂得多。不过，匹配的原理都是一样的。现在，你已经了解了  是如何进行字符串匹配的。下面，让我们来看一下本文的重点：回溯法。我们将使用下面的例子，以便更好的解释回朔法。这是一个比较简单的例子。正则表达式以  开始，以  结束。它们之间有以 1-3 个  组成的字符串。 的匹配过程如下：让我们回过头来看看用于验证 URL 的正则表达式。出现问题的 URL 如下：我们将正则表达式分为三个部分：可以发现，验证  协议这部分的正则表达式没有什么问题。但是，当用  验证  时，匹配过程如下：这是正则表达式中的第一个问题。另一个问题出现在正则表达式的第三部分。可以看到，有问题的 URL 具有下划线（）和百分号（），但是与第三部分对应的正则表达式中则没有。因此，只有在匹配完一长串字符之后，程序才发现两者不匹配，然后进行回溯。这是这个正则表达式中的第二个问题。你已经知道回溯是导致问题的原因。所以，解决问题的方法就是减少回溯。事实上，你会发现，如果把下划线和百分比符号添加到第三部分，程序就会变得正常。运行上面的程序，它会打印出“  ”。如果未来其他的 URL 中含有别的混乱字符怎么办？ 再次修正代码？ 当然不现实！事实上，正则表达式有三种模式： ，和。如果你在正则表达式中添加一个  标志，贪婪模式将变成勉强模式。此时，它将尽可能少地匹配。然而，勉强模式下回溯仍可能出现。例如：正则表达式的第一个字符  与字符串的第一个字符  相匹配。正则表达式的第二个运算符  匹配了字符串的第二个字符  。由于最小匹配的原则，正则表达式将读取第三个运算符 ，并与字符串第三个字符  进行比较。两者不匹配。因此，程序进行回溯并将正则表达式的第二个运算符  与字符串的第三个字符  进行比较。现在匹配成功了。之后，正则表达式的第三个匹配符  与字符串的第四个字符  正相匹配。匹配结束。如果添加 标志，则原来的贪婪模式将变成独占模式。也就是说，它将匹配尽可能多的字符，但不会回溯。因此，如果你想将这个问题完全解决。你必须保证表达式能正确的行使它的功能，同时确保没有回溯发生。我在上述验证 URL 的正则表达式的第二部分增添了一个加号： 现在，程序运行没有问题了。最后，我推荐一个网站。它可以检查你写的正则表达式以及相应的匹配字符串是否存在问题。例如，本文中存在问题的 URL 在使用上述网站检测后，会弹出如下提示：灾难性的回溯。当你单击左下角的 “regex debugger” 时，它将告诉你已经进行了多少步匹配，列出所有的匹配步骤，并指出发生回溯的地方。本文中的正则表达式在 110,000 次尝试之后自动停止。这表明，正则表达式存在一定的问题并需要改进。`但是，当我用如下修改后的正则表达式测试时：网站提示，仅用了 58 步就完成了匹配。一个字符的差异导致了巨大的性能差距。一个小小的正则表达式也能神奇的让 CPU 卡死。这给我们提了一个醒。当遇到正则表达式的时候，一定要注意“贪婪模式”以及回溯问题。", "img": "https://www.tutorialdocs.com/upload/2018/08/regex-trap-01.png"}
{"url": "http://blog.jobbole.com/114551/", "path": "bole/学会这两件事，让你成为 Git 老司机.jpg", "title": "学会这两件事，让你成为 Git 老司机", "desc": "“我在提交中犯了个错误，我如何修正它？”，“我的提交历史一团糟，我该如何让它更整洁？”如果你曾经有上述问题，那么这篇文章很适合你。这篇文章介绍了一个让你成为 Git 老司机的清单。", "content": "如果你曾经有上述问题，那么这篇文章很适合你。这篇文章介绍了一个让你成为 Git 老司机的清单。情景 1假设你已经提交了一堆文件，并发现输入的提交信息实际上并不清晰。现在你要更改提交消息。为此，你可以使用 ：假设你要提交六个文件，但你最终错误地只提交了五个文件。你可能认为可以创建新提交并将第六个文件添加到该提交。这种方法没错。但是，为了保持整洁的提交历史，如果你可以以某种方式将此文件加入到你之前的提交本身，那岂不是更好？这也可以通过  完成： 表示提交信息不会更改。无论你何时在 Git 进行提交，提交都会附上作者名称和作者电子邮箱。通常，当你第一次配置 Git 时，就需要设置作者和电子邮箱。你无需担心每次提交的作者详细信息。也就是说，对于特定项目，你可能希望使用不同的电子邮箱 ID。你需要使用以下命令为该项目配置电子邮箱 ID：假设你忘记配置电子邮箱，并且已经完成了第一次提交。 命令也可以用于更改先前提交的作者消息。可以使用以下命令更改提交的作者信息：应该本地仓库使用  命令。在远端仓库使用  命令会制造大量混乱。假设你正在处理一段代码。你知道代码大约需要十天完成。在这十天内，其他开发人员也将提交代码到远程仓库。将本地仓库代码与远程仓库代码保持同步是个。这在你拉取请求时会避免许多合并冲突的操作。因此，你应该每两天从远程仓库中拉取一个变更。每次将代码从远程仓库拉取到本地仓库时，都会在本地操作中创建新的合并提交。这意味着你的本地历史提交记录会有大量的合并提交，这会让审阅人员头大。上面是历史提交记录在本地仓库中的显示方式。这就需要用到  了。举个🌰。此图显示了发布（release）分支和功能（feature）分支中的提交。当执行变基时，你的目标是确保功能分支从发布分支获取最新代码。变基命令尝试逐个添加每个提交，并检查冲突。这听起来是不是有点头大？让我画个图帮助理解。这显示了变基内部实际做的事情：你现在是个 Git 老司机了。😃在这篇文章中，你了解到：这两个都是非常实用的概念。探索 Git 的世界，继续学习吧。任选一种支付方式\n                        \n            \n                            \n                    ", "img": "https://camo.githubusercontent.com/d98880e58e8bbcbe39d18692601bdd78ad51057c/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f302a744a713852535f557633523973353645"}
